/*
Class: CS461
Project: 1
File: LexerTest.java
Date: Monday, February 13, 2017
Group: Larry Jacob Nick Luis
 */

package bantam.lexer;

import org.junit.BeforeClass;
import org.junit.Test;

import java.io.IOException;
import java.io.StringReader;
import java.lang.reflect.Array;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.Assert.assertEquals;

/*
 * File: LexerTest.java
 * Author: djskrien
 * Date: 1/8/17
 */

/**
 * Tests regular expressions of the lexer component of the compiler.
 */
public class LexerTest
{
    @BeforeClass
    public static void begin() {
        System.out.println("Begin test");
    }

    /**
     * Tests whether a token generated by the given text has the expected name.
     * @param text  the text used to generate the token
     * @param expectedName  the String name that is expected of the token
     * @throws IOException  if lexer.next_token() throws an IOException
     */
    public void testTokenName(String text, String expectedName) throws IOException {
        Lexer lexer = new Lexer(new StringReader(text));
        assertEquals(expectedName,((Token)lexer.next_token().value).getName());
    }

    /**
     * Tests whether a token generated by the given text has the expected attribute.
     * @param text  the text used to generate the token
     * @param expectedAttr  the String attribute that is expected of the token
     * @throws IOException  if lexer.next_token() throws an IOException
     */
    public void testTokenAttr(String text, String expectedAttr) throws IOException {
        Lexer lexer = new Lexer(new StringReader(text));
        assertEquals(expectedAttr,((Token)lexer.next_token().value).getAttribute());
    }

    /**
     * Tests the following brace tokens:
     * - left brace: {
     * - right brace: }
     * - left square brace: [
     * - right square brace: ]
     * - left parenthesis: (
     * - right parenthesis: )
     * @throws IOException  if lexer.next_token() throws an IOException
     */
    @Test
    public void braceTokens() throws IOException {
        this.testTokenName("{", "LBRACE");
        this.testTokenName("}", "RBRACE");
        this.testTokenName("(", "LPAREN");
        this.testTokenName(")", "RPAREN");
        this.testTokenName("[", "LSQBRACE");
        this.testTokenName("]", "RSQBRACE");
    }

    /**
     * Tests the following operator tokens:
     * - minus: -
     * - plus: +
     * - times: *
     * - divide: /
     * - modulus: %
     * - assign: =
     * - increment: ++
     * - decrement: --
     * - less than: <
     * - greater than: >
     * - equal: ==
     * - not equal: !=
     * - less or equal: <=
     * - greater or equal: >=
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void operatorTokens() throws IOException {
        this.testTokenName("-", "MINUS");
        this.testTokenName("+", "PLUS");
        this.testTokenName("*", "TIMES");
        this.testTokenName("/", "DIVIDE");
        this.testTokenName("%", "MODULUS");
        this.testTokenName("=", "ASSIGN");
        this.testTokenName("++", "INCR");
        this.testTokenName("--", "DECR");
        this.testTokenName("<", "LT");
        this.testTokenName(">", "GT");
        this.testTokenName("==", "EQ");
        this.testTokenName("!=", "NE");
        this.testTokenName("<=", "LEQ");
        this.testTokenName(">=", "GEQ");
    }

    /**
     * Tests the following unsupported characters, separated by commas:
     * ?, @, #, ^, `, ~
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void unsupportedCharacterTokens() throws IOException {
        this.testTokenName("?", "LEX_ERROR");
        this.testTokenName("@", "LEX_ERROR");
        this.testTokenName("#", "LEX_ERROR");
        this.testTokenName("^", "LEX_ERROR");
        this.testTokenName("`", "LEX_ERROR");
        this.testTokenName("~", "LEX_ERROR");
    }

    /**
     * Tests illegal identifiers beginning with a numeric character or an underscore.
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void illegalIdentifierToken() throws IOException{
        this.testTokenName("3name", "LEX_ERROR");
        this.testTokenName("_3", "LEX_ERROR");
        this.testTokenName("3_3", "LEX_ERROR");
    }

    /**
     * Tests boolean tokens.
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void booleanTokens() throws IOException {
        this.testTokenName("true", "TRUE");
        this.testTokenName("false", "FALSE");
    }


    /**
     * Tests string token type and attribute (the text of the string).
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void stringToken() throws IOException {
        this.testTokenName("\"this is a string\"", "STRING_CONST");
        this.testTokenAttr("\"this is a string\"", "this is a string");
    }

    /**
     * Tests illegal unterminated strings including with escaped quotation marks.
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void unterminatedString() throws IOException {
        // unterminated string with escaped quotation
        this.testTokenName("\"sample unterminated string with escaped quote\\\" ",
                "LEX_ERROR");
        this.testTokenAttr("\"sample unterminated string with escaped quote\\\"",
                "String constant unterminated");
        // unterminated string
        this.testTokenName("\"sample unterminated string", "LEX_ERROR");
        this.testTokenAttr("\"sample unterminated string", "String constant " +
                "unterminated");
    }

    /**
     * Tests illegal multi-line strings (i.e. a string that spans multiple lines
     * between two paired double quotation marks)
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void multilineStringToken() throws IOException {
        this.testTokenName("\"this is a multiline \n string\"", "LEX_ERROR");
        this.testTokenAttr("\"this is a multiline \n string\"", "String constant " +
                "spanning multiple lines");
    }

    /**
     * Tests illegal unterminated block comments.
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void unterminatedCommentToken() throws IOException {
        // single line
        this.testTokenName("/*sample multiline comment", "LEX_ERROR");
        this.testTokenAttr("/*unterminated multiline comment", "unterminated multiline " +
                "comment");
        // multiple line
        this.testTokenName("/*sample \n multiline \n comment * /", "LEX_ERROR");
        this.testTokenAttr("/*unterminated multiline comment", "unterminated multiline " +
                "comment");
    }

    /**
     * Tests legal comments (which are ignored).
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void commentToken() throws IOException {
        this.testTokenName("/* ignore me */ 5", "INT_CONST");
        this.testTokenName("/* ignore\n me\n please */ 5", "INT_CONST");
        this.testTokenName("// ignore just this line\n 5","INT_CONST");
    }

    /**
     * Tests the end of file token.
     * @throws IOException
     */
    @Test
    public void EOFToken() throws IOException {
        this.testTokenName("", "EOF");
    }

    /**
     * Tests a whole slew of keywords, including all of the following:
     * for, instanceof, if, return, new,
     * break, else, while, extends, class
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void keywordTokens() throws IOException {
        this.testTokenName("for", "FOR");
        this.testTokenName("instanceof", "INSTANCEOF");
        this.testTokenName("if", "IF");
        this.testTokenName("return", "RETURN");
        this.testTokenName("new", "NEW");
        this.testTokenName("break", "BREAK");
        this.testTokenName("else", "ELSE");
        this.testTokenName("while", "WHILE");
        this.testTokenName("extends", "EXTENDS");
        this.testTokenName("class", "CLASS");
    }

    /**
     * Tests integer constant token type and attribute values.
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void intToken() throws IOException {
        this.testTokenName("0", "INT_CONST");
        this.testTokenName("00001", "INT_CONST");
        this.testTokenName("5435349", "INT_CONST");

        this.testTokenAttr("0", "0");
        this.testTokenAttr("00001", "1");
        this.testTokenAttr("5435349", "5435349");
    }

    /**
     * Tests illegal integer constant tokens.
     * @throws IOException if lexer.next_token() throws an IOException
     */
    @Test
    public void invalidIntToken() throws IOException {
        // ruthless testing
        this.testTokenName("2147483648", "LEX_ERROR");
        this.testTokenName("2147483650", "LEX_ERROR");
        this.testTokenName("2147483700", "LEX_ERROR");
        this.testTokenName("2147484000", "LEX_ERROR");
        this.testTokenName("2147490000", "LEX_ERROR");
        this.testTokenName("2147500000", "LEX_ERROR");
        this.testTokenName("2148000000", "LEX_ERROR"); // I've made my point
        // testing for more than 10 digits
        this.testTokenName("10000000000000", "LEX_ERROR");
        this.testTokenName("0000000510650012308700043", "LEX_ERROR");
    }

}