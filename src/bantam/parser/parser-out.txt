Opening files...
Parsing specification from standard input...
Checking specification...
Warning: Terminal "LEX_ERROR" was declared but never used
Building parse tables...
  Computing non-terminal nullability...
  Computing first sets...
  Building state machine...
  Filling in tables...
*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     ifStmt ::= (*) IF LPAREN expr RPAREN stmt 
  and     ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt 
  under symbol IF
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt 
  under symbol WHILE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt 
  under symbol FOR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     breakStmt ::= (*) BREAK SEMI 
  under symbol BREAK
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     returnStmt ::= (*) RETURN SEMI 
  and     returnStmt ::= (*) RETURN expr 
  under symbol RETURN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     expr ::= (*) LPAREN expr 
  and     castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN 
  and     castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     blockStmt ::= (*) LBRACE stmt_list RBRACE 
  under symbol LBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID 
  under symbol LSQBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     dispatchExpr ::= (*) ID LPAREN expr_list RPAREN 
  and     varExpr ::= (*) ID 
  and     declStmt ::= (*) ID ID ASSIGN expr SEMI 
  and     declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     constExpr ::= (*) INT_CONST 
  under symbol INT_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     constExpr ::= (*) BOOLEAN_CONST 
  under symbol BOOLEAN_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #149
  between stmt_list ::= (*) 
  and     constExpr ::= (*) STRING_CONST 
  under symbol STRING_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #39
  between varExpr ::= ID (*) 
  and     dispatchExpr ::= ID (*) LPAREN expr_list RPAREN 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #178
  between ifStmt ::= IF LPAREN expr RPAREN stmt (*) 
  and     ifStmt ::= IF LPAREN expr RPAREN stmt (*) ELSE stmt 
  under symbol ELSE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     ifStmt ::= (*) IF LPAREN expr RPAREN stmt 
  and     ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt 
  under symbol IF
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt 
  under symbol WHILE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt 
  and     forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt 
  under symbol FOR
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     breakStmt ::= (*) BREAK SEMI 
  under symbol BREAK
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     returnStmt ::= (*) RETURN SEMI 
  and     returnStmt ::= (*) RETURN expr 
  under symbol RETURN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     expr ::= (*) LPAREN expr 
  and     castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN 
  and     castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     blockStmt ::= (*) LBRACE stmt_list RBRACE 
  under symbol LBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID 
  under symbol LSQBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     dispatchExpr ::= (*) ID LPAREN expr_list RPAREN 
  and     varExpr ::= (*) ID 
  and     declStmt ::= (*) ID ID ASSIGN expr SEMI 
  and     declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     constExpr ::= (*) INT_CONST 
  under symbol INT_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     constExpr ::= (*) BOOLEAN_CONST 
  under symbol BOOLEAN_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #134
  between stmt_list ::= (*) 
  and     constExpr ::= (*) STRING_CONST 
  under symbol STRING_CONST
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #88
  between instanceofExpr ::= expr INSTANCEOF ID (*) 
  and     instanceofExpr ::= expr INSTANCEOF ID (*) LSQBRACE RSQBRACE 
  under symbol LSQBRACE
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #6
  between member_list ::= (*) 
  and     field ::= (*) ID ID ASSIGN expr SEMI 
  and     method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE 
  and     field ::= (*) ID LSQBRACE RSQBRACE ID SEMI 
  and     field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI 
  and     field ::= (*) ID ID SEMI 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #9
  between member_list ::= (*) 
  and     field ::= (*) ID ID ASSIGN expr SEMI 
  and     method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE 
  and     field ::= (*) ID LSQBRACE RSQBRACE ID SEMI 
  and     field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI 
  and     field ::= (*) ID ID SEMI 
  under symbol ID
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #105
  between varExpr ::= ID (*) 
  and     dispatchExpr ::= ID (*) LPAREN expr_list RPAREN 
  under symbol LPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #105
  between varExpr ::= ID (*) 
  and     castExpr ::= LPAREN ID (*) RPAREN LPAREN expr RPAREN 
  under symbol RPAREN
  Resolved in favor of shifting.

*** Shift/Reduce conflict found in state #105
  between varExpr ::= ID (*) 
  and     castExpr ::= LPAREN ID (*) LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN 
  under symbol LSQBRACE
  Resolved in favor of shifting.

  Checking for non-reduced productions...
*** Production "arrayExpr ::= LSQBRACE expr RSQBRACE ID LSQBRACE expr RSQBRACE " never reduced
*** Production "arrayExpr ::= ID LSQBRACE expr RSQBRACE " never reduced
*** Production "newArrayExpr ::= NEW ID LSQBRACE expr RSQBRACE " never reduced
*** Production "arrayassignExpr ::= arrayExpr ASSIGN expr " never reduced
Writing parser...
===== Terminals =====
[0]EOF [1]error [2]LEX_ERROR [3]CLASS [4]EXTENDS 
[5]IF [6]ELSE [7]WHILE [8]FOR [9]BREAK 
[10]NEW [11]RETURN [12]INSTANCEOF [13]PLUS [14]MINUS 
[15]TIMES [16]DIVIDE [17]MODULUS [18]NOT [19]AND 
[20]OR [21]EQ [22]NE [23]LT [24]LEQ 
[25]GT [26]GEQ [27]ASSIGN [28]INCR [29]DECR 
[30]LPAREN [31]RPAREN [32]LBRACE [33]RBRACE [34]LSQBRACE 
[35]RSQBRACE [36]SEMI [37]COMMA [38]DOT [39]ID 
[40]INT_CONST [41]BOOLEAN_CONST [42]STRING_CONST 

===== Non terminals =====
[0]$START [1]program [2]class_list [3]class [4]member_list 
[5]member [6]method [7]field [8]expr [9]expr_list 
[10]formal_list [11]formal [12]stmt_list [13]stmt [14]exprStmt 
[15]declStmt [16]ifStmt [17]whileStmt [18]forStmt [19]breakStmt 
[20]returnStmt [21]blockStmt [22]assignExpr [23]castExpr [24]arrayassignExpr 
[25]arrayExpr [26]dispatchExpr [27]newExpr [28]newArrayExpr [29]instanceofExpr 
[30]binaryExpr [31]unaryExpr [32]constExpr [33]varExpr [34]binaryarithExpr 
[35]binarycompExpr [36]binarylogicExpr [37]unarynegExpr [38]unarynotExpr [39]unaryincrExpr 
[40]unarydecrExpr 

===== Productions =====
[0] program ::= class_list 
[1] $START ::= program EOF 
[2] class_list ::= class 
[3] class_list ::= class_list class 
[4] class ::= CLASS ID LBRACE member_list RBRACE 
[5] class ::= CLASS ID EXTENDS ID LBRACE member_list RBRACE 
[6] member_list ::= 
[7] member_list ::= member 
[8] member_list ::= member_list member 
[9] member ::= method 
[10] member ::= field 
[11] method ::= ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE 
[12] field ::= ID ID SEMI 
[13] field ::= ID LSQBRACE RSQBRACE ID SEMI 
[14] field ::= ID ID ASSIGN expr SEMI 
[15] field ::= ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI 
[16] formal_list ::= 
[17] formal_list ::= formal 
[18] formal_list ::= formal_list COMMA formal 
[19] formal ::= ID ID 
[20] formal ::= ID LSQBRACE RSQBRACE ID 
[21] stmt_list ::= 
[22] stmt_list ::= stmt 
[23] stmt_list ::= stmt_list stmt 
[24] stmt ::= exprStmt 
[25] stmt ::= declStmt 
[26] stmt ::= ifStmt 
[27] stmt ::= whileStmt 
[28] stmt ::= forStmt 
[29] stmt ::= breakStmt 
[30] stmt ::= returnStmt 
[31] stmt ::= blockStmt 
[32] exprStmt ::= expr SEMI 
[33] declStmt ::= ID ID ASSIGN expr SEMI 
[34] declStmt ::= ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI 
[35] ifStmt ::= IF LPAREN expr RPAREN stmt 
[36] ifStmt ::= IF LPAREN expr RPAREN stmt ELSE stmt 
[37] whileStmt ::= WHILE LPAREN expr RPAREN stmt 
[38] forStmt ::= FOR LPAREN SEMI SEMI RPAREN stmt 
[39] forStmt ::= FOR LPAREN expr SEMI SEMI RPAREN stmt 
[40] forStmt ::= FOR LPAREN SEMI expr SEMI RPAREN stmt 
[41] forStmt ::= FOR LPAREN SEMI SEMI expr RPAREN stmt 
[42] forStmt ::= FOR LPAREN expr SEMI expr SEMI RPAREN stmt 
[43] forStmt ::= FOR LPAREN expr SEMI SEMI expr RPAREN stmt 
[44] forStmt ::= FOR LPAREN SEMI expr SEMI expr RPAREN stmt 
[45] forStmt ::= FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt 
[46] breakStmt ::= BREAK SEMI 
[47] returnStmt ::= RETURN SEMI 
[48] returnStmt ::= RETURN expr 
[49] blockStmt ::= LBRACE stmt_list RBRACE 
[50] expr_list ::= 
[51] expr_list ::= expr 
[52] expr_list ::= expr_list COMMA expr 
[53] expr ::= assignExpr 
[54] expr ::= dispatchExpr 
[55] expr ::= newExpr 
[56] expr ::= instanceofExpr 
[57] expr ::= castExpr 
[58] expr ::= binaryExpr 
[59] expr ::= unaryExpr 
[60] expr ::= constExpr 
[61] expr ::= varExpr 
[62] expr ::= LPAREN expr 
[63] assignExpr ::= varExpr ASSIGN expr 
[64] arrayassignExpr ::= arrayExpr ASSIGN expr 
[65] dispatchExpr ::= ID LPAREN expr_list RPAREN 
[66] dispatchExpr ::= expr DOT ID LPAREN expr_list RPAREN 
[67] newExpr ::= NEW ID LPAREN RPAREN 
[68] newArrayExpr ::= NEW ID LSQBRACE expr RSQBRACE 
[69] instanceofExpr ::= expr INSTANCEOF ID 
[70] instanceofExpr ::= expr INSTANCEOF ID LSQBRACE RSQBRACE 
[71] castExpr ::= LPAREN ID RPAREN LPAREN expr RPAREN 
[72] castExpr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN 
[73] binaryExpr ::= binaryarithExpr 
[74] binaryExpr ::= binarycompExpr 
[75] binaryExpr ::= binarylogicExpr 
[76] unaryExpr ::= unarynegExpr 
[77] unaryExpr ::= unarynotExpr 
[78] unaryExpr ::= unaryincrExpr 
[79] unaryExpr ::= unarydecrExpr 
[80] constExpr ::= INT_CONST 
[81] constExpr ::= BOOLEAN_CONST 
[82] constExpr ::= STRING_CONST 
[83] binaryarithExpr ::= expr PLUS expr 
[84] binaryarithExpr ::= expr MINUS expr 
[85] binaryarithExpr ::= expr TIMES expr 
[86] binaryarithExpr ::= expr DIVIDE expr 
[87] binaryarithExpr ::= expr MODULUS expr 
[88] binarycompExpr ::= expr EQ expr 
[89] binarycompExpr ::= expr NE expr 
[90] binarycompExpr ::= expr LT expr 
[91] binarycompExpr ::= expr LEQ expr 
[92] binarycompExpr ::= expr GT expr 
[93] binarycompExpr ::= expr GEQ expr 
[94] binarylogicExpr ::= expr AND expr 
[95] binarylogicExpr ::= expr OR expr 
[96] unarynegExpr ::= MINUS expr 
[97] unarynotExpr ::= NOT expr 
[98] unaryincrExpr ::= INCR expr 
[99] unaryincrExpr ::= expr INCR 
[100] unarydecrExpr ::= DECR expr 
[101] unarydecrExpr ::= expr DECR 
[102] varExpr ::= ID 
[103] varExpr ::= LSQBRACE expr DOT RSQBRACE ID 
[104] arrayExpr ::= ID LSQBRACE expr RSQBRACE 
[105] arrayExpr ::= LSQBRACE expr RSQBRACE ID LSQBRACE expr RSQBRACE 

===== Viable Prefix Recognizer =====
START lalr_state [0]: {
  [class ::= (*) CLASS ID EXTENDS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [class_list ::= (*) class , {EOF CLASS }]
  [class ::= (*) CLASS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [$START ::= (*) program EOF , {EOF }]
  [class_list ::= (*) class_list class , {EOF CLASS }]
  [program ::= (*) class_list , {EOF }]
}
transition on CLASS to state [4]
transition on class to state [3]
transition on program to state [2]
transition on class_list to state [1]

-------------------
lalr_state [1]: {
  [class ::= (*) CLASS ID EXTENDS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [class ::= (*) CLASS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [class_list ::= class_list (*) class , {EOF CLASS }]
  [program ::= class_list (*) , {EOF }]
}
transition on CLASS to state [4]
transition on class to state [215]

-------------------
lalr_state [2]: {
  [$START ::= program (*) EOF , {EOF }]
}
transition on EOF to state [214]

-------------------
lalr_state [3]: {
  [class_list ::= class (*) , {EOF CLASS }]
}

-------------------
lalr_state [4]: {
  [class ::= CLASS (*) ID EXTENDS ID LBRACE member_list RBRACE , {EOF CLASS }]
  [class ::= CLASS (*) ID LBRACE member_list RBRACE , {EOF CLASS }]
}
transition on ID to state [5]

-------------------
lalr_state [5]: {
  [class ::= CLASS ID (*) LBRACE member_list RBRACE , {EOF CLASS }]
  [class ::= CLASS ID (*) EXTENDS ID LBRACE member_list RBRACE , {EOF CLASS }]
}
transition on EXTENDS to state [7]
transition on LBRACE to state [6]

-------------------
lalr_state [6]: {
  [field ::= (*) ID ID ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [member_list ::= (*) member_list member , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [class ::= CLASS ID LBRACE (*) member_list RBRACE , {EOF CLASS }]
  [member ::= (*) field , {RBRACE ID }]
  [member_list ::= (*) member , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= (*) ID ID SEMI , {RBRACE ID }]
  [member ::= (*) method , {RBRACE ID }]
  [member_list ::= (*) , {RBRACE ID }]
}
transition on member to state [14]
transition on method to state [13]
transition on field to state [12]
transition on member_list to state [212]
transition on ID to state [10]

-------------------
lalr_state [7]: {
  [class ::= CLASS ID EXTENDS (*) ID LBRACE member_list RBRACE , {EOF CLASS }]
}
transition on ID to state [8]

-------------------
lalr_state [8]: {
  [class ::= CLASS ID EXTENDS ID (*) LBRACE member_list RBRACE , {EOF CLASS }]
}
transition on LBRACE to state [9]

-------------------
lalr_state [9]: {
  [class ::= CLASS ID EXTENDS ID LBRACE (*) member_list RBRACE , {EOF CLASS }]
  [field ::= (*) ID ID ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [member_list ::= (*) member_list member , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [member ::= (*) field , {RBRACE ID }]
  [member_list ::= (*) member , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= (*) ID ID SEMI , {RBRACE ID }]
  [member ::= (*) method , {RBRACE ID }]
  [member_list ::= (*) , {RBRACE ID }]
}
transition on member to state [14]
transition on method to state [13]
transition on field to state [12]
transition on member_list to state [11]
transition on ID to state [10]

-------------------
lalr_state [10]: {
  [field ::= ID (*) LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [field ::= ID (*) LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= ID (*) ID SEMI , {RBRACE ID }]
  [field ::= ID (*) ID ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= ID (*) ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on LSQBRACE to state [18]
transition on ID to state [17]

-------------------
lalr_state [11]: {
  [field ::= (*) ID ID ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [member_list ::= member_list (*) member , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [member ::= (*) field , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= (*) ID ID SEMI , {RBRACE ID }]
  [member ::= (*) method , {RBRACE ID }]
  [class ::= CLASS ID EXTENDS ID LBRACE member_list (*) RBRACE , {EOF CLASS }]
}
transition on member to state [16]
transition on method to state [13]
transition on field to state [12]
transition on RBRACE to state [15]
transition on ID to state [10]

-------------------
lalr_state [12]: {
  [member ::= field (*) , {RBRACE ID }]
}

-------------------
lalr_state [13]: {
  [member ::= method (*) , {RBRACE ID }]
}

-------------------
lalr_state [14]: {
  [member_list ::= member (*) , {RBRACE ID }]
}

-------------------
lalr_state [15]: {
  [class ::= CLASS ID EXTENDS ID LBRACE member_list RBRACE (*) , {EOF CLASS }]
}

-------------------
lalr_state [16]: {
  [member_list ::= member_list member (*) , {RBRACE ID }]
}

-------------------
lalr_state [17]: {
  [field ::= ID ID (*) SEMI , {RBRACE ID }]
  [field ::= ID ID (*) ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= ID ID (*) LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on ASSIGN to state [122]
transition on LPAREN to state [121]
transition on SEMI to state [120]

-------------------
lalr_state [18]: {
  [field ::= ID LSQBRACE (*) RSQBRACE ID SEMI , {RBRACE ID }]
  [field ::= ID LSQBRACE (*) RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
}
transition on RSQBRACE to state [19]

-------------------
lalr_state [19]: {
  [field ::= ID LSQBRACE RSQBRACE (*) ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= ID LSQBRACE RSQBRACE (*) ID SEMI , {RBRACE ID }]
}
transition on ID to state [20]

-------------------
lalr_state [20]: {
  [field ::= ID LSQBRACE RSQBRACE ID (*) ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= ID LSQBRACE RSQBRACE ID (*) SEMI , {RBRACE ID }]
}
transition on ASSIGN to state [22]
transition on SEMI to state [21]

-------------------
lalr_state [21]: {
  [field ::= ID LSQBRACE RSQBRACE ID SEMI (*) , {RBRACE ID }]
}

-------------------
lalr_state [22]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [field ::= ID LSQBRACE RSQBRACE ID ASSIGN (*) expr SEMI , {RBRACE ID }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [29]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [23]: {
  [expr ::= constExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [24]: {
  [binaryExpr ::= binarylogicExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [25]: {
  [expr ::= instanceofExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [26]: {
  [binaryExpr ::= binaryarithExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [27]: {
  [constExpr ::= STRING_CONST (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [28]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= INCR (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [119]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [29]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [field ::= ID LSQBRACE RSQBRACE ID ASSIGN expr (*) SEMI , {RBRACE ID }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on SEMI to state [118]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [30]: {
  [expr ::= castExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [31]: {
  [unaryExpr ::= unarynegExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [32]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= NOT (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [117]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [33]: {
  [unaryExpr ::= unaryincrExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [34]: {
  [binaryExpr ::= binarycompExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [35]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= DECR (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [116]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [36]: {
  [expr ::= dispatchExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [37]: {
  [constExpr ::= BOOLEAN_CONST (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [38]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= LPAREN (*) ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= LPAREN (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= LPAREN (*) ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [105]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [104]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [39]: {
  [dispatchExpr ::= ID (*) LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= ID (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [101]

-------------------
lalr_state [40]: {
  [expr ::= varExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= varExpr (*) ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [99]

-------------------
lalr_state [41]: {
  [constExpr ::= INT_CONST (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [42]: {
  [unaryExpr ::= unarynotExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [43]: {
  [expr ::= newExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [44]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [varExpr ::= LSQBRACE (*) expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [95]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [45]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= MINUS (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [54]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [46]: {
  [expr ::= binaryExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [47]: {
  [newExpr ::= NEW (*) ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [51]

-------------------
lalr_state [48]: {
  [unaryExpr ::= unarydecrExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [49]: {
  [expr ::= unaryExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [50]: {
  [expr ::= assignExpr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [51]: {
  [newExpr ::= NEW ID (*) LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [52]

-------------------
lalr_state [52]: {
  [newExpr ::= NEW ID LPAREN (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RPAREN to state [53]

-------------------
lalr_state [53]: {
  [newExpr ::= NEW ID LPAREN RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [54]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= MINUS expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [55]: {
  [unaryincrExpr ::= expr INCR (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [56]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr AND (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [94]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [57]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr MINUS (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [93]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [58]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr DIVIDE (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [92]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [59]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr MODULUS (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [91]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [60]: {
  [unarydecrExpr ::= expr DECR (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [61]: {
  [instanceofExpr ::= expr INSTANCEOF (*) ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr INSTANCEOF (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [88]

-------------------
lalr_state [62]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr PLUS (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [87]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [63]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr EQ (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [86]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [64]: {
  [dispatchExpr ::= expr DOT (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [79]

-------------------
lalr_state [65]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr GT (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [78]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [66]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr TIMES (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [77]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [67]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr NE (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [76]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [68]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr GEQ (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [75]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [69]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr LT (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [74]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [70]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr OR (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [73]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [71]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr LEQ (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [72]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [72]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr LEQ expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [73]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr OR expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [74]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr LT expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [75]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr GEQ expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [76]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr NE expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [77]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr TIMES expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [78]: {
  [binarycompExpr ::= expr GT expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [79]: {
  [dispatchExpr ::= expr DOT ID (*) LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [80]

-------------------
lalr_state [80]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= (*) , {RPAREN COMMA }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= (*) expr , {RPAREN COMMA }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= (*) expr_list COMMA expr , {RPAREN COMMA }]
  [dispatchExpr ::= expr DOT ID LPAREN (*) expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on expr_list to state [82]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [81]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [81]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= expr (*) , {RPAREN COMMA }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [82]: {
  [dispatchExpr ::= expr DOT ID LPAREN expr_list (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr_list ::= expr_list (*) COMMA expr , {RPAREN COMMA }]
}
transition on RPAREN to state [84]
transition on COMMA to state [83]

-------------------
lalr_state [83]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= expr_list COMMA (*) expr , {RPAREN COMMA }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [85]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [84]: {
  [dispatchExpr ::= expr DOT ID LPAREN expr_list RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [85]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= expr_list COMMA expr (*) , {RPAREN COMMA }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [86]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr EQ expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [87]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr PLUS expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [88]: {
  [instanceofExpr ::= expr INSTANCEOF ID (*) LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr INSTANCEOF ID (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LSQBRACE to state [89]

-------------------
lalr_state [89]: {
  [instanceofExpr ::= expr INSTANCEOF ID LSQBRACE (*) RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RSQBRACE to state [90]

-------------------
lalr_state [90]: {
  [instanceofExpr ::= expr INSTANCEOF ID LSQBRACE RSQBRACE (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [91]: {
  [binaryarithExpr ::= expr MODULUS expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [92]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr DIVIDE expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [93]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr MINUS expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [94]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr AND expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [95]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [varExpr ::= LSQBRACE expr (*) DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [96]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [96]: {
  [varExpr ::= LSQBRACE expr DOT (*) RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr DOT (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR DOT }]
}
transition on RSQBRACE to state [97]
transition on ID to state [79]

-------------------
lalr_state [97]: {
  [varExpr ::= LSQBRACE expr DOT RSQBRACE (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [98]

-------------------
lalr_state [98]: {
  [varExpr ::= LSQBRACE expr DOT RSQBRACE ID (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [99]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= varExpr ASSIGN (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [100]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [100]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= varExpr ASSIGN expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [101]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= (*) , {RPAREN COMMA }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= (*) expr , {RPAREN COMMA }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [dispatchExpr ::= ID LPAREN (*) expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr_list ::= (*) expr_list COMMA expr , {RPAREN COMMA }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN COMMA DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on expr_list to state [102]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [81]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [102]: {
  [dispatchExpr ::= ID LPAREN expr_list (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr_list ::= expr_list (*) COMMA expr , {RPAREN COMMA }]
}
transition on RPAREN to state [103]
transition on COMMA to state [83]

-------------------
lalr_state [103]: {
  [dispatchExpr ::= ID LPAREN expr_list RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [104]: {
  [expr ::= LPAREN expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [105]: {
  [dispatchExpr ::= ID (*) LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= LPAREN ID (*) LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= ID (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= LPAREN ID (*) RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [101]
transition on LSQBRACE to state [107]
transition on RPAREN to state [106]

-------------------
lalr_state [106]: {
  [castExpr ::= LPAREN ID RPAREN (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [113]

-------------------
lalr_state [107]: {
  [castExpr ::= LPAREN ID LSQBRACE (*) RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RSQBRACE to state [108]

-------------------
lalr_state [108]: {
  [castExpr ::= LPAREN ID LSQBRACE RSQBRACE (*) RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RPAREN to state [109]

-------------------
lalr_state [109]: {
  [castExpr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN (*) LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [110]

-------------------
lalr_state [110]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN (*) expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [111]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [111]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on RPAREN to state [112]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [112]: {
  [castExpr ::= LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [113]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= LPAREN ID RPAREN LPAREN (*) expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [114]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [114]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= LPAREN ID RPAREN LPAREN expr (*) RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on RPAREN to state [115]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [115]: {
  [castExpr ::= LPAREN ID RPAREN LPAREN expr RPAREN (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [116]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= DECR expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [117]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= NOT expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [118]: {
  [field ::= ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI (*) , {RBRACE ID }]
}

-------------------
lalr_state [119]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= INCR expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN RPAREN LBRACE RBRACE LSQBRACE SEMI COMMA DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [120]: {
  [field ::= ID ID SEMI (*) , {RBRACE ID }]
}

-------------------
lalr_state [121]: {
  [formal ::= (*) ID ID , {RPAREN COMMA }]
  [formal_list ::= (*) , {RPAREN COMMA }]
  [formal_list ::= (*) formal_list COMMA formal , {RPAREN COMMA }]
  [formal ::= (*) ID LSQBRACE RSQBRACE ID , {RPAREN COMMA }]
  [method ::= ID ID LPAREN (*) formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [formal_list ::= (*) formal , {RPAREN COMMA }]
}
transition on formal to state [127]
transition on ID to state [126]
transition on formal_list to state [125]

-------------------
lalr_state [122]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [field ::= ID ID ASSIGN (*) expr SEMI , {RBRACE ID }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [123]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [123]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [field ::= ID ID ASSIGN expr (*) SEMI , {RBRACE ID }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on SEMI to state [124]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [124]: {
  [field ::= ID ID ASSIGN expr SEMI (*) , {RBRACE ID }]
}

-------------------
lalr_state [125]: {
  [formal_list ::= formal_list (*) COMMA formal , {RPAREN COMMA }]
  [method ::= ID ID LPAREN formal_list (*) RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on RPAREN to state [133]
transition on COMMA to state [132]

-------------------
lalr_state [126]: {
  [formal ::= ID (*) LSQBRACE RSQBRACE ID , {RPAREN COMMA }]
  [formal ::= ID (*) ID , {RPAREN COMMA }]
}
transition on LSQBRACE to state [129]
transition on ID to state [128]

-------------------
lalr_state [127]: {
  [formal_list ::= formal (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [128]: {
  [formal ::= ID ID (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [129]: {
  [formal ::= ID LSQBRACE (*) RSQBRACE ID , {RPAREN COMMA }]
}
transition on RSQBRACE to state [130]

-------------------
lalr_state [130]: {
  [formal ::= ID LSQBRACE RSQBRACE (*) ID , {RPAREN COMMA }]
}
transition on ID to state [131]

-------------------
lalr_state [131]: {
  [formal ::= ID LSQBRACE RSQBRACE ID (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [132]: {
  [formal ::= (*) ID ID , {RPAREN COMMA }]
  [formal_list ::= formal_list COMMA (*) formal , {RPAREN COMMA }]
  [formal ::= (*) ID LSQBRACE RSQBRACE ID , {RPAREN COMMA }]
}
transition on formal to state [211]
transition on ID to state [126]

-------------------
lalr_state [133]: {
  [method ::= ID ID LPAREN formal_list RPAREN (*) LBRACE stmt_list RBRACE , {RBRACE ID }]
}
transition on LBRACE to state [134]

-------------------
lalr_state [134]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [method ::= ID ID LPAREN formal_list RPAREN LBRACE (*) stmt_list RBRACE , {RBRACE ID }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) stmt_list stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [152]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on stmt_list to state [146]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [135]: {
  [stmt ::= whileStmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [136]: {
  [stmt ::= ifStmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [137]: {
  [stmt ::= blockStmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [138]: {
  [stmt ::= forStmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [139]: {
  [forStmt ::= FOR (*) LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR (*) LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR (*) LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR (*) LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR (*) LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR (*) LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR (*) LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR (*) LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [181]

-------------------
lalr_state [140]: {
  [ifStmt ::= IF (*) LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [ifStmt ::= IF (*) LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [175]

-------------------
lalr_state [141]: {
  [dispatchExpr ::= ID (*) LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= ID (*) LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= ID (*) , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [declStmt ::= ID (*) ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [101]
transition on LSQBRACE to state [166]
transition on ID to state [165]

-------------------
lalr_state [142]: {
  [stmt ::= declStmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [143]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binaryarithExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarycompExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [returnStmt ::= RETURN (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) instanceofExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) varExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [returnStmt ::= RETURN (*) expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) assignExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on SEMI to state [164]
transition on expr to state [163]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [144]: {
  [stmt ::= breakStmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [145]: {
  [breakStmt ::= BREAK (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on SEMI to state [162]

-------------------
lalr_state [146]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [method ::= ID ID LPAREN formal_list RPAREN LBRACE stmt_list (*) RBRACE , {RBRACE ID }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= stmt_list (*) stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [160]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on RBRACE to state [161]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [147]: {
  [stmt ::= returnStmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [148]: {
  [stmt ::= exprStmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [149]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= LBRACE (*) stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= (*) stmt_list stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [152]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on stmt_list to state [158]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [150]: {
  [whileStmt ::= WHILE (*) LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LPAREN to state [154]

-------------------
lalr_state [151]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= expr (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on SEMI to state [153]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [152]: {
  [stmt_list ::= stmt (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [153]: {
  [exprStmt ::= expr SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [154]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [whileStmt ::= WHILE LPAREN (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [155]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [155]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [whileStmt ::= WHILE LPAREN expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on RPAREN to state [156]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [156]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [whileStmt ::= WHILE LPAREN expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [157]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [157]: {
  [whileStmt ::= WHILE LPAREN expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [158]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [blockStmt ::= LBRACE stmt_list (*) RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [stmt_list ::= stmt_list (*) stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [160]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on RBRACE to state [159]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [159]: {
  [blockStmt ::= LBRACE stmt_list RBRACE (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [160]: {
  [stmt_list ::= stmt_list stmt (*) , {IF WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [161]: {
  [method ::= ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE (*) , {RBRACE ID }]
}

-------------------
lalr_state [162]: {
  [breakStmt ::= BREAK SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [163]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LT expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [returnStmt ::= RETURN expr (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) OR expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) EQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) GEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) LEQ expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= expr (*) DECR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= expr (*) NE expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= expr (*) AND expr , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= expr (*) INCR , {IF ELSE WHILE FOR BREAK NEW RETURN INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS NOT AND OR EQ NE LT LEQ GT GEQ INCR DECR LPAREN LBRACE RBRACE LSQBRACE DOT ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on LEQ to state [71]
transition on OR to state [70]
transition on LT to state [69]
transition on GEQ to state [68]
transition on NE to state [67]
transition on TIMES to state [66]
transition on GT to state [65]
transition on DOT to state [64]
transition on EQ to state [63]
transition on PLUS to state [62]
transition on INSTANCEOF to state [61]
transition on DECR to state [60]
transition on MODULUS to state [59]
transition on DIVIDE to state [58]
transition on MINUS to state [57]
transition on AND to state [56]
transition on INCR to state [55]

-------------------
lalr_state [164]: {
  [returnStmt ::= RETURN SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [165]: {
  [declStmt ::= ID ID (*) ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [172]

-------------------
lalr_state [166]: {
  [declStmt ::= ID LSQBRACE (*) RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on RSQBRACE to state [167]

-------------------
lalr_state [167]: {
  [declStmt ::= ID LSQBRACE RSQBRACE (*) ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ID to state [168]

-------------------
lalr_state [168]: {
  [declStmt ::= ID LSQBRACE RSQBRACE ID (*) ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ASSIGN to state [169]

-------------------
lalr_state [169]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= ID LSQBRACE RSQBRACE ID ASSIGN (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [170]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [170]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= ID LSQBRACE RSQBRACE ID ASSIGN expr (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on SEMI to state [171]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [171]: {
  [declStmt ::= ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [172]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= ID ID ASSIGN (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [173]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [173]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= ID ID ASSIGN expr (*) SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on SEMI to state [174]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [174]: {
  [declStmt ::= ID ID ASSIGN expr SEMI (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [175]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [ifStmt ::= IF LPAREN (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [ifStmt ::= IF LPAREN (*) expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on expr to state [176]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [176]: {
  [ifStmt ::= IF LPAREN expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [ifStmt ::= IF LPAREN expr (*) RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on RPAREN to state [177]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [177]: {
  [ifStmt ::= IF LPAREN expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [ifStmt ::= IF LPAREN expr RPAREN (*) stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [178]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [178]: {
  [ifStmt ::= IF LPAREN expr RPAREN stmt (*) ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [ifStmt ::= IF LPAREN expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on ELSE to state [179]

-------------------
lalr_state [179]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [ifStmt ::= IF LPAREN expr RPAREN stmt ELSE (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [180]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [180]: {
  [ifStmt ::= IF LPAREN expr RPAREN stmt ELSE stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [181]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN (*) SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN (*) expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN (*) SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN (*) expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN (*) expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN (*) SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN (*) SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN (*) expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on SEMI to state [183]
transition on expr to state [182]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [182]: {
  [forStmt ::= FOR LPAREN expr (*) SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr (*) SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr (*) SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr (*) SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on SEMI to state [197]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [183]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN SEMI (*) SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN SEMI (*) SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN SEMI (*) expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN SEMI (*) expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on SEMI to state [185]
transition on expr to state [184]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [184]: {
  [forStmt ::= FOR LPAREN SEMI expr (*) SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN SEMI expr (*) SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on SEMI to state [191]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [185]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN SEMI SEMI (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN SEMI SEMI (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on RPAREN to state [187]
transition on expr to state [186]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [186]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN SEMI SEMI expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on RPAREN to state [189]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [187]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR LPAREN SEMI SEMI RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [188]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [188]: {
  [forStmt ::= FOR LPAREN SEMI SEMI RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [189]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR LPAREN SEMI SEMI expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [190]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [190]: {
  [forStmt ::= FOR LPAREN SEMI SEMI expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [191]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN SEMI expr SEMI (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN SEMI expr SEMI (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on RPAREN to state [193]
transition on expr to state [192]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binarylogicExpr to state [24]
transition on constExpr to state [23]

-------------------
lalr_state [192]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN SEMI expr SEMI expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on RPAREN to state [195]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [193]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR LPAREN SEMI expr SEMI RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [194]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [194]: {
  [forStmt ::= FOR LPAREN SEMI expr SEMI RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [195]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR LPAREN SEMI expr SEMI expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [196]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [196]: {
  [forStmt ::= FOR LPAREN SEMI expr SEMI expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [197]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr SEMI (*) expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr SEMI (*) SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr SEMI (*) SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr SEMI (*) expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on SEMI to state [199]
transition on expr to state [198]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [198]: {
  [forStmt ::= FOR LPAREN expr SEMI expr (*) SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr SEMI expr (*) SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on SEMI to state [205]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [199]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN expr SEMI SEMI (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN expr SEMI SEMI (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on RPAREN to state [201]
transition on expr to state [200]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [200]: {
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN expr SEMI SEMI expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on RPAREN to state [203]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [201]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR LPAREN expr SEMI SEMI RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [202]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [202]: {
  [forStmt ::= FOR LPAREN expr SEMI SEMI RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [203]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR LPAREN expr SEMI SEMI expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [204]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [204]: {
  [forStmt ::= FOR LPAREN expr SEMI SEMI expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [205]: {
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN expr SEMI expr SEMI (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [forStmt ::= FOR LPAREN expr SEMI expr SEMI (*) expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on assignExpr to state [50]
transition on unaryExpr to state [49]
transition on unarydecrExpr to state [48]
transition on NEW to state [47]
transition on binaryExpr to state [46]
transition on MINUS to state [45]
transition on LSQBRACE to state [44]
transition on newExpr to state [43]
transition on unarynotExpr to state [42]
transition on INT_CONST to state [41]
transition on varExpr to state [40]
transition on ID to state [39]
transition on LPAREN to state [38]
transition on BOOLEAN_CONST to state [37]
transition on dispatchExpr to state [36]
transition on DECR to state [35]
transition on binarycompExpr to state [34]
transition on unaryincrExpr to state [33]
transition on NOT to state [32]
transition on unarynegExpr to state [31]
transition on castExpr to state [30]
transition on RPAREN to state [207]
transition on expr to state [206]
transition on INCR to state [28]
transition on STRING_CONST to state [27]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on constExpr to state [23]
transition on binarylogicExpr to state [24]

-------------------
lalr_state [206]: {
  [forStmt ::= FOR LPAREN expr SEMI expr SEMI expr (*) RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= expr (*) MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [dispatchExpr ::= expr (*) DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unarydecrExpr ::= expr (*) DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [instanceofExpr ::= expr (*) INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binaryarithExpr ::= expr (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarycompExpr ::= expr (*) NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [binarylogicExpr ::= expr (*) AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
  [unaryincrExpr ::= expr (*) INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR RPAREN DOT }]
}
transition on MODULUS to state [59]
transition on INSTANCEOF to state [61]
transition on LEQ to state [71]
transition on EQ to state [63]
transition on DOT to state [64]
transition on MINUS to state [57]
transition on DIVIDE to state [58]
transition on GT to state [65]
transition on DECR to state [60]
transition on RPAREN to state [209]
transition on OR to state [70]
transition on PLUS to state [62]
transition on NE to state [67]
transition on LT to state [69]
transition on INCR to state [55]
transition on AND to state [56]
transition on GEQ to state [68]
transition on TIMES to state [66]

-------------------
lalr_state [207]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [forStmt ::= FOR LPAREN expr SEMI expr SEMI RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [208]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [208]: {
  [forStmt ::= FOR LPAREN expr SEMI expr SEMI RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [209]: {
  [binaryarithExpr ::= (*) expr MODULUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) varExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynegExpr ::= (*) MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID LSQBRACE RSQBRACE , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unarydecrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) assignExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) whileStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr EQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= FOR LPAREN expr SEMI expr SEMI expr RPAREN (*) stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [expr ::= (*) LPAREN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [ifStmt ::= (*) IF LPAREN expr RPAREN stmt ELSE stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarynotExpr ::= (*) NOT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) INT_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) dispatchExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) forStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr NE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [assignExpr ::= (*) varExpr ASSIGN expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [whileStmt ::= (*) WHILE LPAREN expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) INCR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [castExpr ::= (*) LPAREN ID LSQBRACE RSQBRACE RPAREN LPAREN expr RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [breakStmt ::= (*) BREAK SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) BOOLEAN_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) newExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) breakStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryincrExpr ::= (*) expr INCR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binaryarithExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [constExpr ::= (*) STRING_CONST , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) instanceofExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) returnStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr LEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) DECR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarycompExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [returnStmt ::= (*) RETURN expr , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr PLUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) castExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) blockStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GT expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [dispatchExpr ::= (*) expr DOT ID LPAREN expr_list RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unarydecrExpr ::= (*) expr DECR , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [binaryExpr ::= (*) binarylogicExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [blockStmt ::= (*) LBRACE stmt_list RBRACE , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr MINUS expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) binaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [exprStmt ::= (*) expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarycompExpr ::= (*) expr GEQ expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [newExpr ::= (*) NEW ID LPAREN RPAREN , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynegExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) exprStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr TIMES expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) unaryExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr AND expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI expr SEMI RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [varExpr ::= (*) LSQBRACE expr DOT RSQBRACE ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ ASSIGN INCR DECR SEMI DOT }]
  [unaryExpr ::= (*) unarynotExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) declStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binaryarithExpr ::= (*) expr DIVIDE expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [expr ::= (*) constExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [declStmt ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [binarylogicExpr ::= (*) expr OR expr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [instanceofExpr ::= (*) expr INSTANCEOF ID , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [forStmt ::= (*) FOR LPAREN expr SEMI SEMI expr RPAREN stmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
  [unaryExpr ::= (*) unaryincrExpr , {INSTANCEOF PLUS MINUS TIMES DIVIDE MODULUS AND OR EQ NE LT LEQ GT GEQ INCR DECR SEMI DOT }]
  [stmt ::= (*) ifStmt , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}
transition on stmt to state [210]
transition on unaryincrExpr to state [33]
transition on STRING_CONST to state [27]
transition on BOOLEAN_CONST to state [37]
transition on varExpr to state [40]
transition on expr to state [151]
transition on WHILE to state [150]
transition on unarynotExpr to state [42]
transition on LBRACE to state [149]
transition on exprStmt to state [148]
transition on returnStmt to state [147]
transition on BREAK to state [145]
transition on breakStmt to state [144]
transition on binarylogicExpr to state [24]
transition on NEW to state [47]
transition on dispatchExpr to state [36]
transition on INT_CONST to state [41]
transition on unarydecrExpr to state [48]
transition on RETURN to state [143]
transition on newExpr to state [43]
transition on declStmt to state [142]
transition on ID to state [141]
transition on LSQBRACE to state [44]
transition on IF to state [140]
transition on constExpr to state [23]
transition on binaryarithExpr to state [26]
transition on instanceofExpr to state [25]
transition on binaryExpr to state [46]
transition on NOT to state [32]
transition on castExpr to state [30]
transition on MINUS to state [45]
transition on FOR to state [139]
transition on binarycompExpr to state [34]
transition on INCR to state [28]
transition on DECR to state [35]
transition on LPAREN to state [38]
transition on forStmt to state [138]
transition on unarynegExpr to state [31]
transition on blockStmt to state [137]
transition on assignExpr to state [50]
transition on ifStmt to state [136]
transition on unaryExpr to state [49]
transition on whileStmt to state [135]

-------------------
lalr_state [210]: {
  [forStmt ::= FOR LPAREN expr SEMI expr SEMI expr RPAREN stmt (*) , {IF ELSE WHILE FOR BREAK NEW RETURN MINUS NOT INCR DECR LPAREN LBRACE RBRACE LSQBRACE ID INT_CONST BOOLEAN_CONST STRING_CONST }]
}

-------------------
lalr_state [211]: {
  [formal_list ::= formal_list COMMA formal (*) , {RPAREN COMMA }]
}

-------------------
lalr_state [212]: {
  [field ::= (*) ID ID ASSIGN expr SEMI , {RBRACE ID }]
  [method ::= (*) ID ID LPAREN formal_list RPAREN LBRACE stmt_list RBRACE , {RBRACE ID }]
  [member_list ::= member_list (*) member , {RBRACE ID }]
  [class ::= CLASS ID LBRACE member_list (*) RBRACE , {EOF CLASS }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID SEMI , {RBRACE ID }]
  [member ::= (*) field , {RBRACE ID }]
  [field ::= (*) ID LSQBRACE RSQBRACE ID ASSIGN expr SEMI , {RBRACE ID }]
  [field ::= (*) ID ID SEMI , {RBRACE ID }]
  [member ::= (*) method , {RBRACE ID }]
}
transition on member to state [16]
transition on method to state [13]
transition on field to state [12]
transition on RBRACE to state [213]
transition on ID to state [10]

-------------------
lalr_state [213]: {
  [class ::= CLASS ID LBRACE member_list RBRACE (*) , {EOF CLASS }]
}

-------------------
lalr_state [214]: {
  [$START ::= program EOF (*) , {EOF }]
}

-------------------
lalr_state [215]: {
  [class_list ::= class_list class (*) , {EOF CLASS }]
}

-------------------
-------- ACTION_TABLE --------
From state #0
 [term 3:SHIFT(to state 4)]
From state #1
 [term 0:REDUCE(with prod 0)] [term 3:SHIFT(to state 4)]
From state #2
 [term 0:SHIFT(to state 214)]
From state #3
 [term 0:REDUCE(with prod 2)] [term 3:REDUCE(with prod 2)]
From state #4
 [term 39:SHIFT(to state 5)]
From state #5
 [term 4:SHIFT(to state 7)] [term 32:SHIFT(to state 6)]
From state #6
 [term 33:REDUCE(with prod 6)] [term 39:SHIFT(to state 10)]
From state #7
 [term 39:SHIFT(to state 8)]
From state #8
 [term 32:SHIFT(to state 9)]
From state #9
 [term 33:REDUCE(with prod 6)] [term 39:SHIFT(to state 10)]
From state #10
 [term 34:SHIFT(to state 18)] [term 39:SHIFT(to state 17)]
From state #11
 [term 33:SHIFT(to state 15)] [term 39:SHIFT(to state 10)]
From state #12
 [term 33:REDUCE(with prod 10)] [term 39:REDUCE(with prod 10)]
From state #13
 [term 33:REDUCE(with prod 9)] [term 39:REDUCE(with prod 9)]
From state #14
 [term 33:REDUCE(with prod 7)] [term 39:REDUCE(with prod 7)]
From state #15
 [term 0:REDUCE(with prod 5)] [term 3:REDUCE(with prod 5)]
From state #16
 [term 33:REDUCE(with prod 8)] [term 39:REDUCE(with prod 8)]
From state #17
 [term 27:SHIFT(to state 122)] [term 30:SHIFT(to state 121)]
 [term 36:SHIFT(to state 120)]
From state #18
 [term 35:SHIFT(to state 19)]
From state #19
 [term 39:SHIFT(to state 20)]
From state #20
 [term 27:SHIFT(to state 22)] [term 36:SHIFT(to state 21)]
From state #21
 [term 33:REDUCE(with prod 13)] [term 39:REDUCE(with prod 13)]
From state #22
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #23
 [term 5:REDUCE(with prod 60)] [term 6:REDUCE(with prod 60)]
 [term 7:REDUCE(with prod 60)] [term 8:REDUCE(with prod 60)]
 [term 9:REDUCE(with prod 60)] [term 10:REDUCE(with prod 60)]
 [term 11:REDUCE(with prod 60)] [term 12:REDUCE(with prod 60)]
 [term 13:REDUCE(with prod 60)] [term 14:REDUCE(with prod 60)]
 [term 15:REDUCE(with prod 60)] [term 16:REDUCE(with prod 60)]
 [term 17:REDUCE(with prod 60)] [term 18:REDUCE(with prod 60)]
 [term 19:REDUCE(with prod 60)] [term 20:REDUCE(with prod 60)]
 [term 21:REDUCE(with prod 60)] [term 22:REDUCE(with prod 60)]
 [term 23:REDUCE(with prod 60)] [term 24:REDUCE(with prod 60)]
 [term 25:REDUCE(with prod 60)] [term 26:REDUCE(with prod 60)]
 [term 28:REDUCE(with prod 60)] [term 29:REDUCE(with prod 60)]
 [term 30:REDUCE(with prod 60)] [term 31:REDUCE(with prod 60)]
 [term 32:REDUCE(with prod 60)] [term 33:REDUCE(with prod 60)]
 [term 34:REDUCE(with prod 60)] [term 36:REDUCE(with prod 60)]
 [term 37:REDUCE(with prod 60)] [term 38:REDUCE(with prod 60)]
 [term 39:REDUCE(with prod 60)] [term 40:REDUCE(with prod 60)]
 [term 41:REDUCE(with prod 60)] [term 42:REDUCE(with prod 60)]
From state #24
 [term 5:REDUCE(with prod 75)] [term 6:REDUCE(with prod 75)]
 [term 7:REDUCE(with prod 75)] [term 8:REDUCE(with prod 75)]
 [term 9:REDUCE(with prod 75)] [term 10:REDUCE(with prod 75)]
 [term 11:REDUCE(with prod 75)] [term 12:REDUCE(with prod 75)]
 [term 13:REDUCE(with prod 75)] [term 14:REDUCE(with prod 75)]
 [term 15:REDUCE(with prod 75)] [term 16:REDUCE(with prod 75)]
 [term 17:REDUCE(with prod 75)] [term 18:REDUCE(with prod 75)]
 [term 19:REDUCE(with prod 75)] [term 20:REDUCE(with prod 75)]
 [term 21:REDUCE(with prod 75)] [term 22:REDUCE(with prod 75)]
 [term 23:REDUCE(with prod 75)] [term 24:REDUCE(with prod 75)]
 [term 25:REDUCE(with prod 75)] [term 26:REDUCE(with prod 75)]
 [term 28:REDUCE(with prod 75)] [term 29:REDUCE(with prod 75)]
 [term 30:REDUCE(with prod 75)] [term 31:REDUCE(with prod 75)]
 [term 32:REDUCE(with prod 75)] [term 33:REDUCE(with prod 75)]
 [term 34:REDUCE(with prod 75)] [term 36:REDUCE(with prod 75)]
 [term 37:REDUCE(with prod 75)] [term 38:REDUCE(with prod 75)]
 [term 39:REDUCE(with prod 75)] [term 40:REDUCE(with prod 75)]
 [term 41:REDUCE(with prod 75)] [term 42:REDUCE(with prod 75)]
From state #25
 [term 5:REDUCE(with prod 56)] [term 6:REDUCE(with prod 56)]
 [term 7:REDUCE(with prod 56)] [term 8:REDUCE(with prod 56)]
 [term 9:REDUCE(with prod 56)] [term 10:REDUCE(with prod 56)]
 [term 11:REDUCE(with prod 56)] [term 12:REDUCE(with prod 56)]
 [term 13:REDUCE(with prod 56)] [term 14:REDUCE(with prod 56)]
 [term 15:REDUCE(with prod 56)] [term 16:REDUCE(with prod 56)]
 [term 17:REDUCE(with prod 56)] [term 18:REDUCE(with prod 56)]
 [term 19:REDUCE(with prod 56)] [term 20:REDUCE(with prod 56)]
 [term 21:REDUCE(with prod 56)] [term 22:REDUCE(with prod 56)]
 [term 23:REDUCE(with prod 56)] [term 24:REDUCE(with prod 56)]
 [term 25:REDUCE(with prod 56)] [term 26:REDUCE(with prod 56)]
 [term 28:REDUCE(with prod 56)] [term 29:REDUCE(with prod 56)]
 [term 30:REDUCE(with prod 56)] [term 31:REDUCE(with prod 56)]
 [term 32:REDUCE(with prod 56)] [term 33:REDUCE(with prod 56)]
 [term 34:REDUCE(with prod 56)] [term 36:REDUCE(with prod 56)]
 [term 37:REDUCE(with prod 56)] [term 38:REDUCE(with prod 56)]
 [term 39:REDUCE(with prod 56)] [term 40:REDUCE(with prod 56)]
 [term 41:REDUCE(with prod 56)] [term 42:REDUCE(with prod 56)]
From state #26
 [term 5:REDUCE(with prod 73)] [term 6:REDUCE(with prod 73)]
 [term 7:REDUCE(with prod 73)] [term 8:REDUCE(with prod 73)]
 [term 9:REDUCE(with prod 73)] [term 10:REDUCE(with prod 73)]
 [term 11:REDUCE(with prod 73)] [term 12:REDUCE(with prod 73)]
 [term 13:REDUCE(with prod 73)] [term 14:REDUCE(with prod 73)]
 [term 15:REDUCE(with prod 73)] [term 16:REDUCE(with prod 73)]
 [term 17:REDUCE(with prod 73)] [term 18:REDUCE(with prod 73)]
 [term 19:REDUCE(with prod 73)] [term 20:REDUCE(with prod 73)]
 [term 21:REDUCE(with prod 73)] [term 22:REDUCE(with prod 73)]
 [term 23:REDUCE(with prod 73)] [term 24:REDUCE(with prod 73)]
 [term 25:REDUCE(with prod 73)] [term 26:REDUCE(with prod 73)]
 [term 28:REDUCE(with prod 73)] [term 29:REDUCE(with prod 73)]
 [term 30:REDUCE(with prod 73)] [term 31:REDUCE(with prod 73)]
 [term 32:REDUCE(with prod 73)] [term 33:REDUCE(with prod 73)]
 [term 34:REDUCE(with prod 73)] [term 36:REDUCE(with prod 73)]
 [term 37:REDUCE(with prod 73)] [term 38:REDUCE(with prod 73)]
 [term 39:REDUCE(with prod 73)] [term 40:REDUCE(with prod 73)]
 [term 41:REDUCE(with prod 73)] [term 42:REDUCE(with prod 73)]
From state #27
 [term 5:REDUCE(with prod 82)] [term 6:REDUCE(with prod 82)]
 [term 7:REDUCE(with prod 82)] [term 8:REDUCE(with prod 82)]
 [term 9:REDUCE(with prod 82)] [term 10:REDUCE(with prod 82)]
 [term 11:REDUCE(with prod 82)] [term 12:REDUCE(with prod 82)]
 [term 13:REDUCE(with prod 82)] [term 14:REDUCE(with prod 82)]
 [term 15:REDUCE(with prod 82)] [term 16:REDUCE(with prod 82)]
 [term 17:REDUCE(with prod 82)] [term 18:REDUCE(with prod 82)]
 [term 19:REDUCE(with prod 82)] [term 20:REDUCE(with prod 82)]
 [term 21:REDUCE(with prod 82)] [term 22:REDUCE(with prod 82)]
 [term 23:REDUCE(with prod 82)] [term 24:REDUCE(with prod 82)]
 [term 25:REDUCE(with prod 82)] [term 26:REDUCE(with prod 82)]
 [term 28:REDUCE(with prod 82)] [term 29:REDUCE(with prod 82)]
 [term 30:REDUCE(with prod 82)] [term 31:REDUCE(with prod 82)]
 [term 32:REDUCE(with prod 82)] [term 33:REDUCE(with prod 82)]
 [term 34:REDUCE(with prod 82)] [term 36:REDUCE(with prod 82)]
 [term 37:REDUCE(with prod 82)] [term 38:REDUCE(with prod 82)]
 [term 39:REDUCE(with prod 82)] [term 40:REDUCE(with prod 82)]
 [term 41:REDUCE(with prod 82)] [term 42:REDUCE(with prod 82)]
From state #28
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #29
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 36:SHIFT(to state 118)] [term 38:SHIFT(to state 64)]
From state #30
 [term 5:REDUCE(with prod 57)] [term 6:REDUCE(with prod 57)]
 [term 7:REDUCE(with prod 57)] [term 8:REDUCE(with prod 57)]
 [term 9:REDUCE(with prod 57)] [term 10:REDUCE(with prod 57)]
 [term 11:REDUCE(with prod 57)] [term 12:REDUCE(with prod 57)]
 [term 13:REDUCE(with prod 57)] [term 14:REDUCE(with prod 57)]
 [term 15:REDUCE(with prod 57)] [term 16:REDUCE(with prod 57)]
 [term 17:REDUCE(with prod 57)] [term 18:REDUCE(with prod 57)]
 [term 19:REDUCE(with prod 57)] [term 20:REDUCE(with prod 57)]
 [term 21:REDUCE(with prod 57)] [term 22:REDUCE(with prod 57)]
 [term 23:REDUCE(with prod 57)] [term 24:REDUCE(with prod 57)]
 [term 25:REDUCE(with prod 57)] [term 26:REDUCE(with prod 57)]
 [term 28:REDUCE(with prod 57)] [term 29:REDUCE(with prod 57)]
 [term 30:REDUCE(with prod 57)] [term 31:REDUCE(with prod 57)]
 [term 32:REDUCE(with prod 57)] [term 33:REDUCE(with prod 57)]
 [term 34:REDUCE(with prod 57)] [term 36:REDUCE(with prod 57)]
 [term 37:REDUCE(with prod 57)] [term 38:REDUCE(with prod 57)]
 [term 39:REDUCE(with prod 57)] [term 40:REDUCE(with prod 57)]
 [term 41:REDUCE(with prod 57)] [term 42:REDUCE(with prod 57)]
From state #31
 [term 5:REDUCE(with prod 76)] [term 6:REDUCE(with prod 76)]
 [term 7:REDUCE(with prod 76)] [term 8:REDUCE(with prod 76)]
 [term 9:REDUCE(with prod 76)] [term 10:REDUCE(with prod 76)]
 [term 11:REDUCE(with prod 76)] [term 12:REDUCE(with prod 76)]
 [term 13:REDUCE(with prod 76)] [term 14:REDUCE(with prod 76)]
 [term 15:REDUCE(with prod 76)] [term 16:REDUCE(with prod 76)]
 [term 17:REDUCE(with prod 76)] [term 18:REDUCE(with prod 76)]
 [term 19:REDUCE(with prod 76)] [term 20:REDUCE(with prod 76)]
 [term 21:REDUCE(with prod 76)] [term 22:REDUCE(with prod 76)]
 [term 23:REDUCE(with prod 76)] [term 24:REDUCE(with prod 76)]
 [term 25:REDUCE(with prod 76)] [term 26:REDUCE(with prod 76)]
 [term 28:REDUCE(with prod 76)] [term 29:REDUCE(with prod 76)]
 [term 30:REDUCE(with prod 76)] [term 31:REDUCE(with prod 76)]
 [term 32:REDUCE(with prod 76)] [term 33:REDUCE(with prod 76)]
 [term 34:REDUCE(with prod 76)] [term 36:REDUCE(with prod 76)]
 [term 37:REDUCE(with prod 76)] [term 38:REDUCE(with prod 76)]
 [term 39:REDUCE(with prod 76)] [term 40:REDUCE(with prod 76)]
 [term 41:REDUCE(with prod 76)] [term 42:REDUCE(with prod 76)]
From state #32
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #33
 [term 5:REDUCE(with prod 78)] [term 6:REDUCE(with prod 78)]
 [term 7:REDUCE(with prod 78)] [term 8:REDUCE(with prod 78)]
 [term 9:REDUCE(with prod 78)] [term 10:REDUCE(with prod 78)]
 [term 11:REDUCE(with prod 78)] [term 12:REDUCE(with prod 78)]
 [term 13:REDUCE(with prod 78)] [term 14:REDUCE(with prod 78)]
 [term 15:REDUCE(with prod 78)] [term 16:REDUCE(with prod 78)]
 [term 17:REDUCE(with prod 78)] [term 18:REDUCE(with prod 78)]
 [term 19:REDUCE(with prod 78)] [term 20:REDUCE(with prod 78)]
 [term 21:REDUCE(with prod 78)] [term 22:REDUCE(with prod 78)]
 [term 23:REDUCE(with prod 78)] [term 24:REDUCE(with prod 78)]
 [term 25:REDUCE(with prod 78)] [term 26:REDUCE(with prod 78)]
 [term 28:REDUCE(with prod 78)] [term 29:REDUCE(with prod 78)]
 [term 30:REDUCE(with prod 78)] [term 31:REDUCE(with prod 78)]
 [term 32:REDUCE(with prod 78)] [term 33:REDUCE(with prod 78)]
 [term 34:REDUCE(with prod 78)] [term 36:REDUCE(with prod 78)]
 [term 37:REDUCE(with prod 78)] [term 38:REDUCE(with prod 78)]
 [term 39:REDUCE(with prod 78)] [term 40:REDUCE(with prod 78)]
 [term 41:REDUCE(with prod 78)] [term 42:REDUCE(with prod 78)]
From state #34
 [term 5:REDUCE(with prod 74)] [term 6:REDUCE(with prod 74)]
 [term 7:REDUCE(with prod 74)] [term 8:REDUCE(with prod 74)]
 [term 9:REDUCE(with prod 74)] [term 10:REDUCE(with prod 74)]
 [term 11:REDUCE(with prod 74)] [term 12:REDUCE(with prod 74)]
 [term 13:REDUCE(with prod 74)] [term 14:REDUCE(with prod 74)]
 [term 15:REDUCE(with prod 74)] [term 16:REDUCE(with prod 74)]
 [term 17:REDUCE(with prod 74)] [term 18:REDUCE(with prod 74)]
 [term 19:REDUCE(with prod 74)] [term 20:REDUCE(with prod 74)]
 [term 21:REDUCE(with prod 74)] [term 22:REDUCE(with prod 74)]
 [term 23:REDUCE(with prod 74)] [term 24:REDUCE(with prod 74)]
 [term 25:REDUCE(with prod 74)] [term 26:REDUCE(with prod 74)]
 [term 28:REDUCE(with prod 74)] [term 29:REDUCE(with prod 74)]
 [term 30:REDUCE(with prod 74)] [term 31:REDUCE(with prod 74)]
 [term 32:REDUCE(with prod 74)] [term 33:REDUCE(with prod 74)]
 [term 34:REDUCE(with prod 74)] [term 36:REDUCE(with prod 74)]
 [term 37:REDUCE(with prod 74)] [term 38:REDUCE(with prod 74)]
 [term 39:REDUCE(with prod 74)] [term 40:REDUCE(with prod 74)]
 [term 41:REDUCE(with prod 74)] [term 42:REDUCE(with prod 74)]
From state #35
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #36
 [term 5:REDUCE(with prod 54)] [term 6:REDUCE(with prod 54)]
 [term 7:REDUCE(with prod 54)] [term 8:REDUCE(with prod 54)]
 [term 9:REDUCE(with prod 54)] [term 10:REDUCE(with prod 54)]
 [term 11:REDUCE(with prod 54)] [term 12:REDUCE(with prod 54)]
 [term 13:REDUCE(with prod 54)] [term 14:REDUCE(with prod 54)]
 [term 15:REDUCE(with prod 54)] [term 16:REDUCE(with prod 54)]
 [term 17:REDUCE(with prod 54)] [term 18:REDUCE(with prod 54)]
 [term 19:REDUCE(with prod 54)] [term 20:REDUCE(with prod 54)]
 [term 21:REDUCE(with prod 54)] [term 22:REDUCE(with prod 54)]
 [term 23:REDUCE(with prod 54)] [term 24:REDUCE(with prod 54)]
 [term 25:REDUCE(with prod 54)] [term 26:REDUCE(with prod 54)]
 [term 28:REDUCE(with prod 54)] [term 29:REDUCE(with prod 54)]
 [term 30:REDUCE(with prod 54)] [term 31:REDUCE(with prod 54)]
 [term 32:REDUCE(with prod 54)] [term 33:REDUCE(with prod 54)]
 [term 34:REDUCE(with prod 54)] [term 36:REDUCE(with prod 54)]
 [term 37:REDUCE(with prod 54)] [term 38:REDUCE(with prod 54)]
 [term 39:REDUCE(with prod 54)] [term 40:REDUCE(with prod 54)]
 [term 41:REDUCE(with prod 54)] [term 42:REDUCE(with prod 54)]
From state #37
 [term 5:REDUCE(with prod 81)] [term 6:REDUCE(with prod 81)]
 [term 7:REDUCE(with prod 81)] [term 8:REDUCE(with prod 81)]
 [term 9:REDUCE(with prod 81)] [term 10:REDUCE(with prod 81)]
 [term 11:REDUCE(with prod 81)] [term 12:REDUCE(with prod 81)]
 [term 13:REDUCE(with prod 81)] [term 14:REDUCE(with prod 81)]
 [term 15:REDUCE(with prod 81)] [term 16:REDUCE(with prod 81)]
 [term 17:REDUCE(with prod 81)] [term 18:REDUCE(with prod 81)]
 [term 19:REDUCE(with prod 81)] [term 20:REDUCE(with prod 81)]
 [term 21:REDUCE(with prod 81)] [term 22:REDUCE(with prod 81)]
 [term 23:REDUCE(with prod 81)] [term 24:REDUCE(with prod 81)]
 [term 25:REDUCE(with prod 81)] [term 26:REDUCE(with prod 81)]
 [term 28:REDUCE(with prod 81)] [term 29:REDUCE(with prod 81)]
 [term 30:REDUCE(with prod 81)] [term 31:REDUCE(with prod 81)]
 [term 32:REDUCE(with prod 81)] [term 33:REDUCE(with prod 81)]
 [term 34:REDUCE(with prod 81)] [term 36:REDUCE(with prod 81)]
 [term 37:REDUCE(with prod 81)] [term 38:REDUCE(with prod 81)]
 [term 39:REDUCE(with prod 81)] [term 40:REDUCE(with prod 81)]
 [term 41:REDUCE(with prod 81)] [term 42:REDUCE(with prod 81)]
From state #38
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 105)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #39
 [term 5:REDUCE(with prod 102)] [term 6:REDUCE(with prod 102)]
 [term 7:REDUCE(with prod 102)] [term 8:REDUCE(with prod 102)]
 [term 9:REDUCE(with prod 102)] [term 10:REDUCE(with prod 102)]
 [term 11:REDUCE(with prod 102)] [term 12:REDUCE(with prod 102)]
 [term 13:REDUCE(with prod 102)] [term 14:REDUCE(with prod 102)]
 [term 15:REDUCE(with prod 102)] [term 16:REDUCE(with prod 102)]
 [term 17:REDUCE(with prod 102)] [term 18:REDUCE(with prod 102)]
 [term 19:REDUCE(with prod 102)] [term 20:REDUCE(with prod 102)]
 [term 21:REDUCE(with prod 102)] [term 22:REDUCE(with prod 102)]
 [term 23:REDUCE(with prod 102)] [term 24:REDUCE(with prod 102)]
 [term 25:REDUCE(with prod 102)] [term 26:REDUCE(with prod 102)]
 [term 27:REDUCE(with prod 102)] [term 28:REDUCE(with prod 102)]
 [term 29:REDUCE(with prod 102)] [term 30:SHIFT(to state 101)]
 [term 31:REDUCE(with prod 102)] [term 32:REDUCE(with prod 102)]
 [term 33:REDUCE(with prod 102)] [term 34:REDUCE(with prod 102)]
 [term 36:REDUCE(with prod 102)] [term 37:REDUCE(with prod 102)]
 [term 38:REDUCE(with prod 102)] [term 39:REDUCE(with prod 102)]
 [term 40:REDUCE(with prod 102)] [term 41:REDUCE(with prod 102)]
 [term 42:REDUCE(with prod 102)]
From state #40
 [term 5:REDUCE(with prod 61)] [term 6:REDUCE(with prod 61)]
 [term 7:REDUCE(with prod 61)] [term 8:REDUCE(with prod 61)]
 [term 9:REDUCE(with prod 61)] [term 10:REDUCE(with prod 61)]
 [term 11:REDUCE(with prod 61)] [term 12:REDUCE(with prod 61)]
 [term 13:REDUCE(with prod 61)] [term 14:REDUCE(with prod 61)]
 [term 15:REDUCE(with prod 61)] [term 16:REDUCE(with prod 61)]
 [term 17:REDUCE(with prod 61)] [term 18:REDUCE(with prod 61)]
 [term 19:REDUCE(with prod 61)] [term 20:REDUCE(with prod 61)]
 [term 21:REDUCE(with prod 61)] [term 22:REDUCE(with prod 61)]
 [term 23:REDUCE(with prod 61)] [term 24:REDUCE(with prod 61)]
 [term 25:REDUCE(with prod 61)] [term 26:REDUCE(with prod 61)]
 [term 27:SHIFT(to state 99)] [term 28:REDUCE(with prod 61)]
 [term 29:REDUCE(with prod 61)] [term 30:REDUCE(with prod 61)]
 [term 31:REDUCE(with prod 61)] [term 32:REDUCE(with prod 61)]
 [term 33:REDUCE(with prod 61)] [term 34:REDUCE(with prod 61)]
 [term 36:REDUCE(with prod 61)] [term 37:REDUCE(with prod 61)]
 [term 38:REDUCE(with prod 61)] [term 39:REDUCE(with prod 61)]
 [term 40:REDUCE(with prod 61)] [term 41:REDUCE(with prod 61)]
 [term 42:REDUCE(with prod 61)]
From state #41
 [term 5:REDUCE(with prod 80)] [term 6:REDUCE(with prod 80)]
 [term 7:REDUCE(with prod 80)] [term 8:REDUCE(with prod 80)]
 [term 9:REDUCE(with prod 80)] [term 10:REDUCE(with prod 80)]
 [term 11:REDUCE(with prod 80)] [term 12:REDUCE(with prod 80)]
 [term 13:REDUCE(with prod 80)] [term 14:REDUCE(with prod 80)]
 [term 15:REDUCE(with prod 80)] [term 16:REDUCE(with prod 80)]
 [term 17:REDUCE(with prod 80)] [term 18:REDUCE(with prod 80)]
 [term 19:REDUCE(with prod 80)] [term 20:REDUCE(with prod 80)]
 [term 21:REDUCE(with prod 80)] [term 22:REDUCE(with prod 80)]
 [term 23:REDUCE(with prod 80)] [term 24:REDUCE(with prod 80)]
 [term 25:REDUCE(with prod 80)] [term 26:REDUCE(with prod 80)]
 [term 28:REDUCE(with prod 80)] [term 29:REDUCE(with prod 80)]
 [term 30:REDUCE(with prod 80)] [term 31:REDUCE(with prod 80)]
 [term 32:REDUCE(with prod 80)] [term 33:REDUCE(with prod 80)]
 [term 34:REDUCE(with prod 80)] [term 36:REDUCE(with prod 80)]
 [term 37:REDUCE(with prod 80)] [term 38:REDUCE(with prod 80)]
 [term 39:REDUCE(with prod 80)] [term 40:REDUCE(with prod 80)]
 [term 41:REDUCE(with prod 80)] [term 42:REDUCE(with prod 80)]
From state #42
 [term 5:REDUCE(with prod 77)] [term 6:REDUCE(with prod 77)]
 [term 7:REDUCE(with prod 77)] [term 8:REDUCE(with prod 77)]
 [term 9:REDUCE(with prod 77)] [term 10:REDUCE(with prod 77)]
 [term 11:REDUCE(with prod 77)] [term 12:REDUCE(with prod 77)]
 [term 13:REDUCE(with prod 77)] [term 14:REDUCE(with prod 77)]
 [term 15:REDUCE(with prod 77)] [term 16:REDUCE(with prod 77)]
 [term 17:REDUCE(with prod 77)] [term 18:REDUCE(with prod 77)]
 [term 19:REDUCE(with prod 77)] [term 20:REDUCE(with prod 77)]
 [term 21:REDUCE(with prod 77)] [term 22:REDUCE(with prod 77)]
 [term 23:REDUCE(with prod 77)] [term 24:REDUCE(with prod 77)]
 [term 25:REDUCE(with prod 77)] [term 26:REDUCE(with prod 77)]
 [term 28:REDUCE(with prod 77)] [term 29:REDUCE(with prod 77)]
 [term 30:REDUCE(with prod 77)] [term 31:REDUCE(with prod 77)]
 [term 32:REDUCE(with prod 77)] [term 33:REDUCE(with prod 77)]
 [term 34:REDUCE(with prod 77)] [term 36:REDUCE(with prod 77)]
 [term 37:REDUCE(with prod 77)] [term 38:REDUCE(with prod 77)]
 [term 39:REDUCE(with prod 77)] [term 40:REDUCE(with prod 77)]
 [term 41:REDUCE(with prod 77)] [term 42:REDUCE(with prod 77)]
From state #43
 [term 5:REDUCE(with prod 55)] [term 6:REDUCE(with prod 55)]
 [term 7:REDUCE(with prod 55)] [term 8:REDUCE(with prod 55)]
 [term 9:REDUCE(with prod 55)] [term 10:REDUCE(with prod 55)]
 [term 11:REDUCE(with prod 55)] [term 12:REDUCE(with prod 55)]
 [term 13:REDUCE(with prod 55)] [term 14:REDUCE(with prod 55)]
 [term 15:REDUCE(with prod 55)] [term 16:REDUCE(with prod 55)]
 [term 17:REDUCE(with prod 55)] [term 18:REDUCE(with prod 55)]
 [term 19:REDUCE(with prod 55)] [term 20:REDUCE(with prod 55)]
 [term 21:REDUCE(with prod 55)] [term 22:REDUCE(with prod 55)]
 [term 23:REDUCE(with prod 55)] [term 24:REDUCE(with prod 55)]
 [term 25:REDUCE(with prod 55)] [term 26:REDUCE(with prod 55)]
 [term 28:REDUCE(with prod 55)] [term 29:REDUCE(with prod 55)]
 [term 30:REDUCE(with prod 55)] [term 31:REDUCE(with prod 55)]
 [term 32:REDUCE(with prod 55)] [term 33:REDUCE(with prod 55)]
 [term 34:REDUCE(with prod 55)] [term 36:REDUCE(with prod 55)]
 [term 37:REDUCE(with prod 55)] [term 38:REDUCE(with prod 55)]
 [term 39:REDUCE(with prod 55)] [term 40:REDUCE(with prod 55)]
 [term 41:REDUCE(with prod 55)] [term 42:REDUCE(with prod 55)]
From state #44
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #45
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #46
 [term 5:REDUCE(with prod 58)] [term 6:REDUCE(with prod 58)]
 [term 7:REDUCE(with prod 58)] [term 8:REDUCE(with prod 58)]
 [term 9:REDUCE(with prod 58)] [term 10:REDUCE(with prod 58)]
 [term 11:REDUCE(with prod 58)] [term 12:REDUCE(with prod 58)]
 [term 13:REDUCE(with prod 58)] [term 14:REDUCE(with prod 58)]
 [term 15:REDUCE(with prod 58)] [term 16:REDUCE(with prod 58)]
 [term 17:REDUCE(with prod 58)] [term 18:REDUCE(with prod 58)]
 [term 19:REDUCE(with prod 58)] [term 20:REDUCE(with prod 58)]
 [term 21:REDUCE(with prod 58)] [term 22:REDUCE(with prod 58)]
 [term 23:REDUCE(with prod 58)] [term 24:REDUCE(with prod 58)]
 [term 25:REDUCE(with prod 58)] [term 26:REDUCE(with prod 58)]
 [term 28:REDUCE(with prod 58)] [term 29:REDUCE(with prod 58)]
 [term 30:REDUCE(with prod 58)] [term 31:REDUCE(with prod 58)]
 [term 32:REDUCE(with prod 58)] [term 33:REDUCE(with prod 58)]
 [term 34:REDUCE(with prod 58)] [term 36:REDUCE(with prod 58)]
 [term 37:REDUCE(with prod 58)] [term 38:REDUCE(with prod 58)]
 [term 39:REDUCE(with prod 58)] [term 40:REDUCE(with prod 58)]
 [term 41:REDUCE(with prod 58)] [term 42:REDUCE(with prod 58)]
From state #47
 [term 39:SHIFT(to state 51)]
From state #48
 [term 5:REDUCE(with prod 79)] [term 6:REDUCE(with prod 79)]
 [term 7:REDUCE(with prod 79)] [term 8:REDUCE(with prod 79)]
 [term 9:REDUCE(with prod 79)] [term 10:REDUCE(with prod 79)]
 [term 11:REDUCE(with prod 79)] [term 12:REDUCE(with prod 79)]
 [term 13:REDUCE(with prod 79)] [term 14:REDUCE(with prod 79)]
 [term 15:REDUCE(with prod 79)] [term 16:REDUCE(with prod 79)]
 [term 17:REDUCE(with prod 79)] [term 18:REDUCE(with prod 79)]
 [term 19:REDUCE(with prod 79)] [term 20:REDUCE(with prod 79)]
 [term 21:REDUCE(with prod 79)] [term 22:REDUCE(with prod 79)]
 [term 23:REDUCE(with prod 79)] [term 24:REDUCE(with prod 79)]
 [term 25:REDUCE(with prod 79)] [term 26:REDUCE(with prod 79)]
 [term 28:REDUCE(with prod 79)] [term 29:REDUCE(with prod 79)]
 [term 30:REDUCE(with prod 79)] [term 31:REDUCE(with prod 79)]
 [term 32:REDUCE(with prod 79)] [term 33:REDUCE(with prod 79)]
 [term 34:REDUCE(with prod 79)] [term 36:REDUCE(with prod 79)]
 [term 37:REDUCE(with prod 79)] [term 38:REDUCE(with prod 79)]
 [term 39:REDUCE(with prod 79)] [term 40:REDUCE(with prod 79)]
 [term 41:REDUCE(with prod 79)] [term 42:REDUCE(with prod 79)]
From state #49
 [term 5:REDUCE(with prod 59)] [term 6:REDUCE(with prod 59)]
 [term 7:REDUCE(with prod 59)] [term 8:REDUCE(with prod 59)]
 [term 9:REDUCE(with prod 59)] [term 10:REDUCE(with prod 59)]
 [term 11:REDUCE(with prod 59)] [term 12:REDUCE(with prod 59)]
 [term 13:REDUCE(with prod 59)] [term 14:REDUCE(with prod 59)]
 [term 15:REDUCE(with prod 59)] [term 16:REDUCE(with prod 59)]
 [term 17:REDUCE(with prod 59)] [term 18:REDUCE(with prod 59)]
 [term 19:REDUCE(with prod 59)] [term 20:REDUCE(with prod 59)]
 [term 21:REDUCE(with prod 59)] [term 22:REDUCE(with prod 59)]
 [term 23:REDUCE(with prod 59)] [term 24:REDUCE(with prod 59)]
 [term 25:REDUCE(with prod 59)] [term 26:REDUCE(with prod 59)]
 [term 28:REDUCE(with prod 59)] [term 29:REDUCE(with prod 59)]
 [term 30:REDUCE(with prod 59)] [term 31:REDUCE(with prod 59)]
 [term 32:REDUCE(with prod 59)] [term 33:REDUCE(with prod 59)]
 [term 34:REDUCE(with prod 59)] [term 36:REDUCE(with prod 59)]
 [term 37:REDUCE(with prod 59)] [term 38:REDUCE(with prod 59)]
 [term 39:REDUCE(with prod 59)] [term 40:REDUCE(with prod 59)]
 [term 41:REDUCE(with prod 59)] [term 42:REDUCE(with prod 59)]
From state #50
 [term 5:REDUCE(with prod 53)] [term 6:REDUCE(with prod 53)]
 [term 7:REDUCE(with prod 53)] [term 8:REDUCE(with prod 53)]
 [term 9:REDUCE(with prod 53)] [term 10:REDUCE(with prod 53)]
 [term 11:REDUCE(with prod 53)] [term 12:REDUCE(with prod 53)]
 [term 13:REDUCE(with prod 53)] [term 14:REDUCE(with prod 53)]
 [term 15:REDUCE(with prod 53)] [term 16:REDUCE(with prod 53)]
 [term 17:REDUCE(with prod 53)] [term 18:REDUCE(with prod 53)]
 [term 19:REDUCE(with prod 53)] [term 20:REDUCE(with prod 53)]
 [term 21:REDUCE(with prod 53)] [term 22:REDUCE(with prod 53)]
 [term 23:REDUCE(with prod 53)] [term 24:REDUCE(with prod 53)]
 [term 25:REDUCE(with prod 53)] [term 26:REDUCE(with prod 53)]
 [term 28:REDUCE(with prod 53)] [term 29:REDUCE(with prod 53)]
 [term 30:REDUCE(with prod 53)] [term 31:REDUCE(with prod 53)]
 [term 32:REDUCE(with prod 53)] [term 33:REDUCE(with prod 53)]
 [term 34:REDUCE(with prod 53)] [term 36:REDUCE(with prod 53)]
 [term 37:REDUCE(with prod 53)] [term 38:REDUCE(with prod 53)]
 [term 39:REDUCE(with prod 53)] [term 40:REDUCE(with prod 53)]
 [term 41:REDUCE(with prod 53)] [term 42:REDUCE(with prod 53)]
From state #51
 [term 30:SHIFT(to state 52)]
From state #52
 [term 31:SHIFT(to state 53)]
From state #53
 [term 5:REDUCE(with prod 67)] [term 6:REDUCE(with prod 67)]
 [term 7:REDUCE(with prod 67)] [term 8:REDUCE(with prod 67)]
 [term 9:REDUCE(with prod 67)] [term 10:REDUCE(with prod 67)]
 [term 11:REDUCE(with prod 67)] [term 12:REDUCE(with prod 67)]
 [term 13:REDUCE(with prod 67)] [term 14:REDUCE(with prod 67)]
 [term 15:REDUCE(with prod 67)] [term 16:REDUCE(with prod 67)]
 [term 17:REDUCE(with prod 67)] [term 18:REDUCE(with prod 67)]
 [term 19:REDUCE(with prod 67)] [term 20:REDUCE(with prod 67)]
 [term 21:REDUCE(with prod 67)] [term 22:REDUCE(with prod 67)]
 [term 23:REDUCE(with prod 67)] [term 24:REDUCE(with prod 67)]
 [term 25:REDUCE(with prod 67)] [term 26:REDUCE(with prod 67)]
 [term 28:REDUCE(with prod 67)] [term 29:REDUCE(with prod 67)]
 [term 30:REDUCE(with prod 67)] [term 31:REDUCE(with prod 67)]
 [term 32:REDUCE(with prod 67)] [term 33:REDUCE(with prod 67)]
 [term 34:REDUCE(with prod 67)] [term 36:REDUCE(with prod 67)]
 [term 37:REDUCE(with prod 67)] [term 38:REDUCE(with prod 67)]
 [term 39:REDUCE(with prod 67)] [term 40:REDUCE(with prod 67)]
 [term 41:REDUCE(with prod 67)] [term 42:REDUCE(with prod 67)]
From state #54
 [term 5:REDUCE(with prod 96)] [term 6:REDUCE(with prod 96)]
 [term 7:REDUCE(with prod 96)] [term 8:REDUCE(with prod 96)]
 [term 9:REDUCE(with prod 96)] [term 10:REDUCE(with prod 96)]
 [term 11:REDUCE(with prod 96)] [term 12:REDUCE(with prod 96)]
 [term 13:REDUCE(with prod 96)] [term 14:REDUCE(with prod 96)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 96)]
 [term 19:REDUCE(with prod 96)] [term 20:REDUCE(with prod 96)]
 [term 21:REDUCE(with prod 96)] [term 22:REDUCE(with prod 96)]
 [term 23:REDUCE(with prod 96)] [term 24:REDUCE(with prod 96)]
 [term 25:REDUCE(with prod 96)] [term 26:REDUCE(with prod 96)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 96)] [term 31:REDUCE(with prod 96)]
 [term 32:REDUCE(with prod 96)] [term 33:REDUCE(with prod 96)]
 [term 34:REDUCE(with prod 96)] [term 36:REDUCE(with prod 96)]
 [term 37:REDUCE(with prod 96)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 96)] [term 40:REDUCE(with prod 96)]
 [term 41:REDUCE(with prod 96)] [term 42:REDUCE(with prod 96)]
From state #55
 [term 5:REDUCE(with prod 99)] [term 6:REDUCE(with prod 99)]
 [term 7:REDUCE(with prod 99)] [term 8:REDUCE(with prod 99)]
 [term 9:REDUCE(with prod 99)] [term 10:REDUCE(with prod 99)]
 [term 11:REDUCE(with prod 99)] [term 12:REDUCE(with prod 99)]
 [term 13:REDUCE(with prod 99)] [term 14:REDUCE(with prod 99)]
 [term 15:REDUCE(with prod 99)] [term 16:REDUCE(with prod 99)]
 [term 17:REDUCE(with prod 99)] [term 18:REDUCE(with prod 99)]
 [term 19:REDUCE(with prod 99)] [term 20:REDUCE(with prod 99)]
 [term 21:REDUCE(with prod 99)] [term 22:REDUCE(with prod 99)]
 [term 23:REDUCE(with prod 99)] [term 24:REDUCE(with prod 99)]
 [term 25:REDUCE(with prod 99)] [term 26:REDUCE(with prod 99)]
 [term 28:REDUCE(with prod 99)] [term 29:REDUCE(with prod 99)]
 [term 30:REDUCE(with prod 99)] [term 31:REDUCE(with prod 99)]
 [term 32:REDUCE(with prod 99)] [term 33:REDUCE(with prod 99)]
 [term 34:REDUCE(with prod 99)] [term 36:REDUCE(with prod 99)]
 [term 37:REDUCE(with prod 99)] [term 38:REDUCE(with prod 99)]
 [term 39:REDUCE(with prod 99)] [term 40:REDUCE(with prod 99)]
 [term 41:REDUCE(with prod 99)] [term 42:REDUCE(with prod 99)]
From state #56
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #57
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #58
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #59
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #60
 [term 5:REDUCE(with prod 101)] [term 6:REDUCE(with prod 101)]
 [term 7:REDUCE(with prod 101)] [term 8:REDUCE(with prod 101)]
 [term 9:REDUCE(with prod 101)] [term 10:REDUCE(with prod 101)]
 [term 11:REDUCE(with prod 101)] [term 12:REDUCE(with prod 101)]
 [term 13:REDUCE(with prod 101)] [term 14:REDUCE(with prod 101)]
 [term 15:REDUCE(with prod 101)] [term 16:REDUCE(with prod 101)]
 [term 17:REDUCE(with prod 101)] [term 18:REDUCE(with prod 101)]
 [term 19:REDUCE(with prod 101)] [term 20:REDUCE(with prod 101)]
 [term 21:REDUCE(with prod 101)] [term 22:REDUCE(with prod 101)]
 [term 23:REDUCE(with prod 101)] [term 24:REDUCE(with prod 101)]
 [term 25:REDUCE(with prod 101)] [term 26:REDUCE(with prod 101)]
 [term 28:REDUCE(with prod 101)] [term 29:REDUCE(with prod 101)]
 [term 30:REDUCE(with prod 101)] [term 31:REDUCE(with prod 101)]
 [term 32:REDUCE(with prod 101)] [term 33:REDUCE(with prod 101)]
 [term 34:REDUCE(with prod 101)] [term 36:REDUCE(with prod 101)]
 [term 37:REDUCE(with prod 101)] [term 38:REDUCE(with prod 101)]
 [term 39:REDUCE(with prod 101)] [term 40:REDUCE(with prod 101)]
 [term 41:REDUCE(with prod 101)] [term 42:REDUCE(with prod 101)]
From state #61
 [term 39:SHIFT(to state 88)]
From state #62
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #63
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #64
 [term 39:SHIFT(to state 79)]
From state #65
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #66
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #67
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #68
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #69
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #70
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #71
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #72
 [term 5:REDUCE(with prod 91)] [term 6:REDUCE(with prod 91)]
 [term 7:REDUCE(with prod 91)] [term 8:REDUCE(with prod 91)]
 [term 9:REDUCE(with prod 91)] [term 10:REDUCE(with prod 91)]
 [term 11:REDUCE(with prod 91)] [term 12:REDUCE(with prod 91)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 91)]
 [term 19:REDUCE(with prod 91)] [term 20:REDUCE(with prod 91)]
 [term 21:REDUCE(with prod 91)] [term 22:REDUCE(with prod 91)]
 [term 23:REDUCE(with prod 91)] [term 24:REDUCE(with prod 91)]
 [term 25:REDUCE(with prod 91)] [term 26:REDUCE(with prod 91)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 91)] [term 31:REDUCE(with prod 91)]
 [term 32:REDUCE(with prod 91)] [term 33:REDUCE(with prod 91)]
 [term 34:REDUCE(with prod 91)] [term 36:REDUCE(with prod 91)]
 [term 37:REDUCE(with prod 91)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 91)] [term 40:REDUCE(with prod 91)]
 [term 41:REDUCE(with prod 91)] [term 42:REDUCE(with prod 91)]
From state #73
 [term 5:REDUCE(with prod 95)] [term 6:REDUCE(with prod 95)]
 [term 7:REDUCE(with prod 95)] [term 8:REDUCE(with prod 95)]
 [term 9:REDUCE(with prod 95)] [term 10:REDUCE(with prod 95)]
 [term 11:REDUCE(with prod 95)] [term 12:SHIFT(to state 61)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 95)]
 [term 19:SHIFT(to state 56)] [term 20:REDUCE(with prod 95)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 95)] [term 31:REDUCE(with prod 95)]
 [term 32:REDUCE(with prod 95)] [term 33:REDUCE(with prod 95)]
 [term 34:REDUCE(with prod 95)] [term 36:REDUCE(with prod 95)]
 [term 37:REDUCE(with prod 95)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 95)] [term 40:REDUCE(with prod 95)]
 [term 41:REDUCE(with prod 95)] [term 42:REDUCE(with prod 95)]
From state #74
 [term 5:REDUCE(with prod 90)] [term 6:REDUCE(with prod 90)]
 [term 7:REDUCE(with prod 90)] [term 8:REDUCE(with prod 90)]
 [term 9:REDUCE(with prod 90)] [term 10:REDUCE(with prod 90)]
 [term 11:REDUCE(with prod 90)] [term 12:REDUCE(with prod 90)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 90)]
 [term 19:REDUCE(with prod 90)] [term 20:REDUCE(with prod 90)]
 [term 21:REDUCE(with prod 90)] [term 22:REDUCE(with prod 90)]
 [term 23:REDUCE(with prod 90)] [term 24:REDUCE(with prod 90)]
 [term 25:REDUCE(with prod 90)] [term 26:REDUCE(with prod 90)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 90)] [term 31:REDUCE(with prod 90)]
 [term 32:REDUCE(with prod 90)] [term 33:REDUCE(with prod 90)]
 [term 34:REDUCE(with prod 90)] [term 36:REDUCE(with prod 90)]
 [term 37:REDUCE(with prod 90)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 90)] [term 40:REDUCE(with prod 90)]
 [term 41:REDUCE(with prod 90)] [term 42:REDUCE(with prod 90)]
From state #75
 [term 5:REDUCE(with prod 93)] [term 6:REDUCE(with prod 93)]
 [term 7:REDUCE(with prod 93)] [term 8:REDUCE(with prod 93)]
 [term 9:REDUCE(with prod 93)] [term 10:REDUCE(with prod 93)]
 [term 11:REDUCE(with prod 93)] [term 12:REDUCE(with prod 93)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 93)]
 [term 19:REDUCE(with prod 93)] [term 20:REDUCE(with prod 93)]
 [term 21:REDUCE(with prod 93)] [term 22:REDUCE(with prod 93)]
 [term 23:REDUCE(with prod 93)] [term 24:REDUCE(with prod 93)]
 [term 25:REDUCE(with prod 93)] [term 26:REDUCE(with prod 93)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 93)] [term 31:REDUCE(with prod 93)]
 [term 32:REDUCE(with prod 93)] [term 33:REDUCE(with prod 93)]
 [term 34:REDUCE(with prod 93)] [term 36:REDUCE(with prod 93)]
 [term 37:REDUCE(with prod 93)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 93)] [term 40:REDUCE(with prod 93)]
 [term 41:REDUCE(with prod 93)] [term 42:REDUCE(with prod 93)]
From state #76
 [term 5:REDUCE(with prod 89)] [term 6:REDUCE(with prod 89)]
 [term 7:REDUCE(with prod 89)] [term 8:REDUCE(with prod 89)]
 [term 9:REDUCE(with prod 89)] [term 10:REDUCE(with prod 89)]
 [term 11:REDUCE(with prod 89)] [term 12:SHIFT(to state 61)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 89)]
 [term 19:REDUCE(with prod 89)] [term 20:REDUCE(with prod 89)]
 [term 21:REDUCE(with prod 89)] [term 22:REDUCE(with prod 89)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 89)] [term 31:REDUCE(with prod 89)]
 [term 32:REDUCE(with prod 89)] [term 33:REDUCE(with prod 89)]
 [term 34:REDUCE(with prod 89)] [term 36:REDUCE(with prod 89)]
 [term 37:REDUCE(with prod 89)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 89)] [term 40:REDUCE(with prod 89)]
 [term 41:REDUCE(with prod 89)] [term 42:REDUCE(with prod 89)]
From state #77
 [term 5:REDUCE(with prod 85)] [term 6:REDUCE(with prod 85)]
 [term 7:REDUCE(with prod 85)] [term 8:REDUCE(with prod 85)]
 [term 9:REDUCE(with prod 85)] [term 10:REDUCE(with prod 85)]
 [term 11:REDUCE(with prod 85)] [term 12:REDUCE(with prod 85)]
 [term 13:REDUCE(with prod 85)] [term 14:REDUCE(with prod 85)]
 [term 15:REDUCE(with prod 85)] [term 16:REDUCE(with prod 85)]
 [term 17:REDUCE(with prod 85)] [term 18:REDUCE(with prod 85)]
 [term 19:REDUCE(with prod 85)] [term 20:REDUCE(with prod 85)]
 [term 21:REDUCE(with prod 85)] [term 22:REDUCE(with prod 85)]
 [term 23:REDUCE(with prod 85)] [term 24:REDUCE(with prod 85)]
 [term 25:REDUCE(with prod 85)] [term 26:REDUCE(with prod 85)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 85)] [term 31:REDUCE(with prod 85)]
 [term 32:REDUCE(with prod 85)] [term 33:REDUCE(with prod 85)]
 [term 34:REDUCE(with prod 85)] [term 36:REDUCE(with prod 85)]
 [term 37:REDUCE(with prod 85)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 85)] [term 40:REDUCE(with prod 85)]
 [term 41:REDUCE(with prod 85)] [term 42:REDUCE(with prod 85)]
From state #78
 [term 5:REDUCE(with prod 92)] [term 6:REDUCE(with prod 92)]
 [term 7:REDUCE(with prod 92)] [term 8:REDUCE(with prod 92)]
 [term 9:REDUCE(with prod 92)] [term 10:REDUCE(with prod 92)]
 [term 11:REDUCE(with prod 92)] [term 12:REDUCE(with prod 92)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 92)]
 [term 19:REDUCE(with prod 92)] [term 20:REDUCE(with prod 92)]
 [term 21:REDUCE(with prod 92)] [term 22:REDUCE(with prod 92)]
 [term 23:REDUCE(with prod 92)] [term 24:REDUCE(with prod 92)]
 [term 25:REDUCE(with prod 92)] [term 26:REDUCE(with prod 92)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 92)] [term 31:REDUCE(with prod 92)]
 [term 32:REDUCE(with prod 92)] [term 33:REDUCE(with prod 92)]
 [term 34:REDUCE(with prod 92)] [term 36:REDUCE(with prod 92)]
 [term 37:REDUCE(with prod 92)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 92)] [term 40:REDUCE(with prod 92)]
 [term 41:REDUCE(with prod 92)] [term 42:REDUCE(with prod 92)]
From state #79
 [term 30:SHIFT(to state 80)]
From state #80
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 31:REDUCE(with prod 50)] [term 34:SHIFT(to state 44)]
 [term 37:REDUCE(with prod 50)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #81
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:REDUCE(with prod 51)] [term 37:REDUCE(with prod 51)]
 [term 38:SHIFT(to state 64)]
From state #82
 [term 31:SHIFT(to state 84)] [term 37:SHIFT(to state 83)]
From state #83
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #84
 [term 5:REDUCE(with prod 66)] [term 6:REDUCE(with prod 66)]
 [term 7:REDUCE(with prod 66)] [term 8:REDUCE(with prod 66)]
 [term 9:REDUCE(with prod 66)] [term 10:REDUCE(with prod 66)]
 [term 11:REDUCE(with prod 66)] [term 12:REDUCE(with prod 66)]
 [term 13:REDUCE(with prod 66)] [term 14:REDUCE(with prod 66)]
 [term 15:REDUCE(with prod 66)] [term 16:REDUCE(with prod 66)]
 [term 17:REDUCE(with prod 66)] [term 18:REDUCE(with prod 66)]
 [term 19:REDUCE(with prod 66)] [term 20:REDUCE(with prod 66)]
 [term 21:REDUCE(with prod 66)] [term 22:REDUCE(with prod 66)]
 [term 23:REDUCE(with prod 66)] [term 24:REDUCE(with prod 66)]
 [term 25:REDUCE(with prod 66)] [term 26:REDUCE(with prod 66)]
 [term 28:REDUCE(with prod 66)] [term 29:REDUCE(with prod 66)]
 [term 30:REDUCE(with prod 66)] [term 31:REDUCE(with prod 66)]
 [term 32:REDUCE(with prod 66)] [term 33:REDUCE(with prod 66)]
 [term 34:REDUCE(with prod 66)] [term 36:REDUCE(with prod 66)]
 [term 37:REDUCE(with prod 66)] [term 38:REDUCE(with prod 66)]
 [term 39:REDUCE(with prod 66)] [term 40:REDUCE(with prod 66)]
 [term 41:REDUCE(with prod 66)] [term 42:REDUCE(with prod 66)]
From state #85
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:REDUCE(with prod 52)] [term 37:REDUCE(with prod 52)]
 [term 38:SHIFT(to state 64)]
From state #86
 [term 5:REDUCE(with prod 88)] [term 6:REDUCE(with prod 88)]
 [term 7:REDUCE(with prod 88)] [term 8:REDUCE(with prod 88)]
 [term 9:REDUCE(with prod 88)] [term 10:REDUCE(with prod 88)]
 [term 11:REDUCE(with prod 88)] [term 12:SHIFT(to state 61)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 88)]
 [term 19:REDUCE(with prod 88)] [term 20:REDUCE(with prod 88)]
 [term 21:REDUCE(with prod 88)] [term 22:REDUCE(with prod 88)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 88)] [term 31:REDUCE(with prod 88)]
 [term 32:REDUCE(with prod 88)] [term 33:REDUCE(with prod 88)]
 [term 34:REDUCE(with prod 88)] [term 36:REDUCE(with prod 88)]
 [term 37:REDUCE(with prod 88)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 88)] [term 40:REDUCE(with prod 88)]
 [term 41:REDUCE(with prod 88)] [term 42:REDUCE(with prod 88)]
From state #87
 [term 5:REDUCE(with prod 83)] [term 6:REDUCE(with prod 83)]
 [term 7:REDUCE(with prod 83)] [term 8:REDUCE(with prod 83)]
 [term 9:REDUCE(with prod 83)] [term 10:REDUCE(with prod 83)]
 [term 11:REDUCE(with prod 83)] [term 12:REDUCE(with prod 83)]
 [term 13:REDUCE(with prod 83)] [term 14:REDUCE(with prod 83)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 83)]
 [term 19:REDUCE(with prod 83)] [term 20:REDUCE(with prod 83)]
 [term 21:REDUCE(with prod 83)] [term 22:REDUCE(with prod 83)]
 [term 23:REDUCE(with prod 83)] [term 24:REDUCE(with prod 83)]
 [term 25:REDUCE(with prod 83)] [term 26:REDUCE(with prod 83)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 83)] [term 31:REDUCE(with prod 83)]
 [term 32:REDUCE(with prod 83)] [term 33:REDUCE(with prod 83)]
 [term 34:REDUCE(with prod 83)] [term 36:REDUCE(with prod 83)]
 [term 37:REDUCE(with prod 83)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 83)] [term 40:REDUCE(with prod 83)]
 [term 41:REDUCE(with prod 83)] [term 42:REDUCE(with prod 83)]
From state #88
 [term 5:REDUCE(with prod 69)] [term 6:REDUCE(with prod 69)]
 [term 7:REDUCE(with prod 69)] [term 8:REDUCE(with prod 69)]
 [term 9:REDUCE(with prod 69)] [term 10:REDUCE(with prod 69)]
 [term 11:REDUCE(with prod 69)] [term 12:REDUCE(with prod 69)]
 [term 13:REDUCE(with prod 69)] [term 14:REDUCE(with prod 69)]
 [term 15:REDUCE(with prod 69)] [term 16:REDUCE(with prod 69)]
 [term 17:REDUCE(with prod 69)] [term 18:REDUCE(with prod 69)]
 [term 19:REDUCE(with prod 69)] [term 20:REDUCE(with prod 69)]
 [term 21:REDUCE(with prod 69)] [term 22:REDUCE(with prod 69)]
 [term 23:REDUCE(with prod 69)] [term 24:REDUCE(with prod 69)]
 [term 25:REDUCE(with prod 69)] [term 26:REDUCE(with prod 69)]
 [term 28:REDUCE(with prod 69)] [term 29:REDUCE(with prod 69)]
 [term 30:REDUCE(with prod 69)] [term 31:REDUCE(with prod 69)]
 [term 32:REDUCE(with prod 69)] [term 33:REDUCE(with prod 69)]
 [term 34:SHIFT(to state 89)] [term 36:REDUCE(with prod 69)]
 [term 37:REDUCE(with prod 69)] [term 38:REDUCE(with prod 69)]
 [term 39:REDUCE(with prod 69)] [term 40:REDUCE(with prod 69)]
 [term 41:REDUCE(with prod 69)] [term 42:REDUCE(with prod 69)]
From state #89
 [term 35:SHIFT(to state 90)]
From state #90
 [term 5:REDUCE(with prod 70)] [term 6:REDUCE(with prod 70)]
 [term 7:REDUCE(with prod 70)] [term 8:REDUCE(with prod 70)]
 [term 9:REDUCE(with prod 70)] [term 10:REDUCE(with prod 70)]
 [term 11:REDUCE(with prod 70)] [term 12:REDUCE(with prod 70)]
 [term 13:REDUCE(with prod 70)] [term 14:REDUCE(with prod 70)]
 [term 15:REDUCE(with prod 70)] [term 16:REDUCE(with prod 70)]
 [term 17:REDUCE(with prod 70)] [term 18:REDUCE(with prod 70)]
 [term 19:REDUCE(with prod 70)] [term 20:REDUCE(with prod 70)]
 [term 21:REDUCE(with prod 70)] [term 22:REDUCE(with prod 70)]
 [term 23:REDUCE(with prod 70)] [term 24:REDUCE(with prod 70)]
 [term 25:REDUCE(with prod 70)] [term 26:REDUCE(with prod 70)]
 [term 28:REDUCE(with prod 70)] [term 29:REDUCE(with prod 70)]
 [term 30:REDUCE(with prod 70)] [term 31:REDUCE(with prod 70)]
 [term 32:REDUCE(with prod 70)] [term 33:REDUCE(with prod 70)]
 [term 34:REDUCE(with prod 70)] [term 36:REDUCE(with prod 70)]
 [term 37:REDUCE(with prod 70)] [term 38:REDUCE(with prod 70)]
 [term 39:REDUCE(with prod 70)] [term 40:REDUCE(with prod 70)]
 [term 41:REDUCE(with prod 70)] [term 42:REDUCE(with prod 70)]
From state #91
 [term 5:REDUCE(with prod 87)] [term 6:REDUCE(with prod 87)]
 [term 7:REDUCE(with prod 87)] [term 8:REDUCE(with prod 87)]
 [term 9:REDUCE(with prod 87)] [term 10:REDUCE(with prod 87)]
 [term 11:REDUCE(with prod 87)] [term 12:REDUCE(with prod 87)]
 [term 13:REDUCE(with prod 87)] [term 14:REDUCE(with prod 87)]
 [term 15:REDUCE(with prod 87)] [term 16:REDUCE(with prod 87)]
 [term 17:REDUCE(with prod 87)] [term 18:REDUCE(with prod 87)]
 [term 19:REDUCE(with prod 87)] [term 20:REDUCE(with prod 87)]
 [term 21:REDUCE(with prod 87)] [term 22:REDUCE(with prod 87)]
 [term 23:REDUCE(with prod 87)] [term 24:REDUCE(with prod 87)]
 [term 25:REDUCE(with prod 87)] [term 26:REDUCE(with prod 87)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 87)] [term 31:REDUCE(with prod 87)]
 [term 32:REDUCE(with prod 87)] [term 33:REDUCE(with prod 87)]
 [term 34:REDUCE(with prod 87)] [term 36:REDUCE(with prod 87)]
 [term 37:REDUCE(with prod 87)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 87)] [term 40:REDUCE(with prod 87)]
 [term 41:REDUCE(with prod 87)] [term 42:REDUCE(with prod 87)]
From state #92
 [term 5:REDUCE(with prod 86)] [term 6:REDUCE(with prod 86)]
 [term 7:REDUCE(with prod 86)] [term 8:REDUCE(with prod 86)]
 [term 9:REDUCE(with prod 86)] [term 10:REDUCE(with prod 86)]
 [term 11:REDUCE(with prod 86)] [term 12:REDUCE(with prod 86)]
 [term 13:REDUCE(with prod 86)] [term 14:REDUCE(with prod 86)]
 [term 15:REDUCE(with prod 86)] [term 16:REDUCE(with prod 86)]
 [term 17:REDUCE(with prod 86)] [term 18:REDUCE(with prod 86)]
 [term 19:REDUCE(with prod 86)] [term 20:REDUCE(with prod 86)]
 [term 21:REDUCE(with prod 86)] [term 22:REDUCE(with prod 86)]
 [term 23:REDUCE(with prod 86)] [term 24:REDUCE(with prod 86)]
 [term 25:REDUCE(with prod 86)] [term 26:REDUCE(with prod 86)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 86)] [term 31:REDUCE(with prod 86)]
 [term 32:REDUCE(with prod 86)] [term 33:REDUCE(with prod 86)]
 [term 34:REDUCE(with prod 86)] [term 36:REDUCE(with prod 86)]
 [term 37:REDUCE(with prod 86)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 86)] [term 40:REDUCE(with prod 86)]
 [term 41:REDUCE(with prod 86)] [term 42:REDUCE(with prod 86)]
From state #93
 [term 5:REDUCE(with prod 84)] [term 6:REDUCE(with prod 84)]
 [term 7:REDUCE(with prod 84)] [term 8:REDUCE(with prod 84)]
 [term 9:REDUCE(with prod 84)] [term 10:REDUCE(with prod 84)]
 [term 11:REDUCE(with prod 84)] [term 12:REDUCE(with prod 84)]
 [term 13:REDUCE(with prod 84)] [term 14:REDUCE(with prod 84)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 84)]
 [term 19:REDUCE(with prod 84)] [term 20:REDUCE(with prod 84)]
 [term 21:REDUCE(with prod 84)] [term 22:REDUCE(with prod 84)]
 [term 23:REDUCE(with prod 84)] [term 24:REDUCE(with prod 84)]
 [term 25:REDUCE(with prod 84)] [term 26:REDUCE(with prod 84)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 84)] [term 31:REDUCE(with prod 84)]
 [term 32:REDUCE(with prod 84)] [term 33:REDUCE(with prod 84)]
 [term 34:REDUCE(with prod 84)] [term 36:REDUCE(with prod 84)]
 [term 37:REDUCE(with prod 84)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 84)] [term 40:REDUCE(with prod 84)]
 [term 41:REDUCE(with prod 84)] [term 42:REDUCE(with prod 84)]
From state #94
 [term 5:REDUCE(with prod 94)] [term 6:REDUCE(with prod 94)]
 [term 7:REDUCE(with prod 94)] [term 8:REDUCE(with prod 94)]
 [term 9:REDUCE(with prod 94)] [term 10:REDUCE(with prod 94)]
 [term 11:REDUCE(with prod 94)] [term 12:SHIFT(to state 61)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 94)]
 [term 19:REDUCE(with prod 94)] [term 20:REDUCE(with prod 94)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 94)] [term 31:REDUCE(with prod 94)]
 [term 32:REDUCE(with prod 94)] [term 33:REDUCE(with prod 94)]
 [term 34:REDUCE(with prod 94)] [term 36:REDUCE(with prod 94)]
 [term 37:REDUCE(with prod 94)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 94)] [term 40:REDUCE(with prod 94)]
 [term 41:REDUCE(with prod 94)] [term 42:REDUCE(with prod 94)]
From state #95
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 38:SHIFT(to state 96)]
From state #96
 [term 35:SHIFT(to state 97)] [term 39:SHIFT(to state 79)]
From state #97
 [term 39:SHIFT(to state 98)]
From state #98
 [term 5:REDUCE(with prod 103)] [term 6:REDUCE(with prod 103)]
 [term 7:REDUCE(with prod 103)] [term 8:REDUCE(with prod 103)]
 [term 9:REDUCE(with prod 103)] [term 10:REDUCE(with prod 103)]
 [term 11:REDUCE(with prod 103)] [term 12:REDUCE(with prod 103)]
 [term 13:REDUCE(with prod 103)] [term 14:REDUCE(with prod 103)]
 [term 15:REDUCE(with prod 103)] [term 16:REDUCE(with prod 103)]
 [term 17:REDUCE(with prod 103)] [term 18:REDUCE(with prod 103)]
 [term 19:REDUCE(with prod 103)] [term 20:REDUCE(with prod 103)]
 [term 21:REDUCE(with prod 103)] [term 22:REDUCE(with prod 103)]
 [term 23:REDUCE(with prod 103)] [term 24:REDUCE(with prod 103)]
 [term 25:REDUCE(with prod 103)] [term 26:REDUCE(with prod 103)]
 [term 27:REDUCE(with prod 103)] [term 28:REDUCE(with prod 103)]
 [term 29:REDUCE(with prod 103)] [term 30:REDUCE(with prod 103)]
 [term 31:REDUCE(with prod 103)] [term 32:REDUCE(with prod 103)]
 [term 33:REDUCE(with prod 103)] [term 34:REDUCE(with prod 103)]
 [term 36:REDUCE(with prod 103)] [term 37:REDUCE(with prod 103)]
 [term 38:REDUCE(with prod 103)] [term 39:REDUCE(with prod 103)]
 [term 40:REDUCE(with prod 103)] [term 41:REDUCE(with prod 103)]
 [term 42:REDUCE(with prod 103)]
From state #99
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #100
 [term 5:REDUCE(with prod 63)] [term 6:REDUCE(with prod 63)]
 [term 7:REDUCE(with prod 63)] [term 8:REDUCE(with prod 63)]
 [term 9:REDUCE(with prod 63)] [term 10:REDUCE(with prod 63)]
 [term 11:REDUCE(with prod 63)] [term 12:SHIFT(to state 61)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 63)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 63)] [term 31:REDUCE(with prod 63)]
 [term 32:REDUCE(with prod 63)] [term 33:REDUCE(with prod 63)]
 [term 34:REDUCE(with prod 63)] [term 36:REDUCE(with prod 63)]
 [term 37:REDUCE(with prod 63)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 63)] [term 40:REDUCE(with prod 63)]
 [term 41:REDUCE(with prod 63)] [term 42:REDUCE(with prod 63)]
From state #101
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 31:REDUCE(with prod 50)] [term 34:SHIFT(to state 44)]
 [term 37:REDUCE(with prod 50)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #102
 [term 31:SHIFT(to state 103)] [term 37:SHIFT(to state 83)]
From state #103
 [term 5:REDUCE(with prod 65)] [term 6:REDUCE(with prod 65)]
 [term 7:REDUCE(with prod 65)] [term 8:REDUCE(with prod 65)]
 [term 9:REDUCE(with prod 65)] [term 10:REDUCE(with prod 65)]
 [term 11:REDUCE(with prod 65)] [term 12:REDUCE(with prod 65)]
 [term 13:REDUCE(with prod 65)] [term 14:REDUCE(with prod 65)]
 [term 15:REDUCE(with prod 65)] [term 16:REDUCE(with prod 65)]
 [term 17:REDUCE(with prod 65)] [term 18:REDUCE(with prod 65)]
 [term 19:REDUCE(with prod 65)] [term 20:REDUCE(with prod 65)]
 [term 21:REDUCE(with prod 65)] [term 22:REDUCE(with prod 65)]
 [term 23:REDUCE(with prod 65)] [term 24:REDUCE(with prod 65)]
 [term 25:REDUCE(with prod 65)] [term 26:REDUCE(with prod 65)]
 [term 28:REDUCE(with prod 65)] [term 29:REDUCE(with prod 65)]
 [term 30:REDUCE(with prod 65)] [term 31:REDUCE(with prod 65)]
 [term 32:REDUCE(with prod 65)] [term 33:REDUCE(with prod 65)]
 [term 34:REDUCE(with prod 65)] [term 36:REDUCE(with prod 65)]
 [term 37:REDUCE(with prod 65)] [term 38:REDUCE(with prod 65)]
 [term 39:REDUCE(with prod 65)] [term 40:REDUCE(with prod 65)]
 [term 41:REDUCE(with prod 65)] [term 42:REDUCE(with prod 65)]
From state #104
 [term 5:REDUCE(with prod 62)] [term 6:REDUCE(with prod 62)]
 [term 7:REDUCE(with prod 62)] [term 8:REDUCE(with prod 62)]
 [term 9:REDUCE(with prod 62)] [term 10:REDUCE(with prod 62)]
 [term 11:REDUCE(with prod 62)] [term 12:SHIFT(to state 61)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 62)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 62)] [term 31:REDUCE(with prod 62)]
 [term 32:REDUCE(with prod 62)] [term 33:REDUCE(with prod 62)]
 [term 34:REDUCE(with prod 62)] [term 36:REDUCE(with prod 62)]
 [term 37:REDUCE(with prod 62)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 62)] [term 40:REDUCE(with prod 62)]
 [term 41:REDUCE(with prod 62)] [term 42:REDUCE(with prod 62)]
From state #105
 [term 5:REDUCE(with prod 102)] [term 6:REDUCE(with prod 102)]
 [term 7:REDUCE(with prod 102)] [term 8:REDUCE(with prod 102)]
 [term 9:REDUCE(with prod 102)] [term 10:REDUCE(with prod 102)]
 [term 11:REDUCE(with prod 102)] [term 12:REDUCE(with prod 102)]
 [term 13:REDUCE(with prod 102)] [term 14:REDUCE(with prod 102)]
 [term 15:REDUCE(with prod 102)] [term 16:REDUCE(with prod 102)]
 [term 17:REDUCE(with prod 102)] [term 18:REDUCE(with prod 102)]
 [term 19:REDUCE(with prod 102)] [term 20:REDUCE(with prod 102)]
 [term 21:REDUCE(with prod 102)] [term 22:REDUCE(with prod 102)]
 [term 23:REDUCE(with prod 102)] [term 24:REDUCE(with prod 102)]
 [term 25:REDUCE(with prod 102)] [term 26:REDUCE(with prod 102)]
 [term 27:REDUCE(with prod 102)] [term 28:REDUCE(with prod 102)]
 [term 29:REDUCE(with prod 102)] [term 30:SHIFT(to state 101)]
 [term 31:SHIFT(to state 106)] [term 32:REDUCE(with prod 102)]
 [term 33:REDUCE(with prod 102)] [term 34:SHIFT(to state 107)]
 [term 36:REDUCE(with prod 102)] [term 37:REDUCE(with prod 102)]
 [term 38:REDUCE(with prod 102)] [term 39:REDUCE(with prod 102)]
 [term 40:REDUCE(with prod 102)] [term 41:REDUCE(with prod 102)]
 [term 42:REDUCE(with prod 102)]
From state #106
 [term 30:SHIFT(to state 113)]
From state #107
 [term 35:SHIFT(to state 108)]
From state #108
 [term 31:SHIFT(to state 109)]
From state #109
 [term 30:SHIFT(to state 110)]
From state #110
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #111
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:SHIFT(to state 112)] [term 38:SHIFT(to state 64)]
From state #112
 [term 5:REDUCE(with prod 72)] [term 6:REDUCE(with prod 72)]
 [term 7:REDUCE(with prod 72)] [term 8:REDUCE(with prod 72)]
 [term 9:REDUCE(with prod 72)] [term 10:REDUCE(with prod 72)]
 [term 11:REDUCE(with prod 72)] [term 12:REDUCE(with prod 72)]
 [term 13:REDUCE(with prod 72)] [term 14:REDUCE(with prod 72)]
 [term 15:REDUCE(with prod 72)] [term 16:REDUCE(with prod 72)]
 [term 17:REDUCE(with prod 72)] [term 18:REDUCE(with prod 72)]
 [term 19:REDUCE(with prod 72)] [term 20:REDUCE(with prod 72)]
 [term 21:REDUCE(with prod 72)] [term 22:REDUCE(with prod 72)]
 [term 23:REDUCE(with prod 72)] [term 24:REDUCE(with prod 72)]
 [term 25:REDUCE(with prod 72)] [term 26:REDUCE(with prod 72)]
 [term 28:REDUCE(with prod 72)] [term 29:REDUCE(with prod 72)]
 [term 30:REDUCE(with prod 72)] [term 31:REDUCE(with prod 72)]
 [term 32:REDUCE(with prod 72)] [term 33:REDUCE(with prod 72)]
 [term 34:REDUCE(with prod 72)] [term 36:REDUCE(with prod 72)]
 [term 37:REDUCE(with prod 72)] [term 38:REDUCE(with prod 72)]
 [term 39:REDUCE(with prod 72)] [term 40:REDUCE(with prod 72)]
 [term 41:REDUCE(with prod 72)] [term 42:REDUCE(with prod 72)]
From state #113
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #114
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:SHIFT(to state 115)] [term 38:SHIFT(to state 64)]
From state #115
 [term 5:REDUCE(with prod 71)] [term 6:REDUCE(with prod 71)]
 [term 7:REDUCE(with prod 71)] [term 8:REDUCE(with prod 71)]
 [term 9:REDUCE(with prod 71)] [term 10:REDUCE(with prod 71)]
 [term 11:REDUCE(with prod 71)] [term 12:REDUCE(with prod 71)]
 [term 13:REDUCE(with prod 71)] [term 14:REDUCE(with prod 71)]
 [term 15:REDUCE(with prod 71)] [term 16:REDUCE(with prod 71)]
 [term 17:REDUCE(with prod 71)] [term 18:REDUCE(with prod 71)]
 [term 19:REDUCE(with prod 71)] [term 20:REDUCE(with prod 71)]
 [term 21:REDUCE(with prod 71)] [term 22:REDUCE(with prod 71)]
 [term 23:REDUCE(with prod 71)] [term 24:REDUCE(with prod 71)]
 [term 25:REDUCE(with prod 71)] [term 26:REDUCE(with prod 71)]
 [term 28:REDUCE(with prod 71)] [term 29:REDUCE(with prod 71)]
 [term 30:REDUCE(with prod 71)] [term 31:REDUCE(with prod 71)]
 [term 32:REDUCE(with prod 71)] [term 33:REDUCE(with prod 71)]
 [term 34:REDUCE(with prod 71)] [term 36:REDUCE(with prod 71)]
 [term 37:REDUCE(with prod 71)] [term 38:REDUCE(with prod 71)]
 [term 39:REDUCE(with prod 71)] [term 40:REDUCE(with prod 71)]
 [term 41:REDUCE(with prod 71)] [term 42:REDUCE(with prod 71)]
From state #116
 [term 5:REDUCE(with prod 100)] [term 6:REDUCE(with prod 100)]
 [term 7:REDUCE(with prod 100)] [term 8:REDUCE(with prod 100)]
 [term 9:REDUCE(with prod 100)] [term 10:REDUCE(with prod 100)]
 [term 11:REDUCE(with prod 100)] [term 12:REDUCE(with prod 100)]
 [term 13:REDUCE(with prod 100)] [term 14:REDUCE(with prod 100)]
 [term 15:REDUCE(with prod 100)] [term 16:REDUCE(with prod 100)]
 [term 17:REDUCE(with prod 100)] [term 18:REDUCE(with prod 100)]
 [term 19:REDUCE(with prod 100)] [term 20:REDUCE(with prod 100)]
 [term 21:REDUCE(with prod 100)] [term 22:REDUCE(with prod 100)]
 [term 23:REDUCE(with prod 100)] [term 24:REDUCE(with prod 100)]
 [term 25:REDUCE(with prod 100)] [term 26:REDUCE(with prod 100)]
 [term 28:REDUCE(with prod 100)] [term 29:REDUCE(with prod 100)]
 [term 30:REDUCE(with prod 100)] [term 31:REDUCE(with prod 100)]
 [term 32:REDUCE(with prod 100)] [term 33:REDUCE(with prod 100)]
 [term 34:REDUCE(with prod 100)] [term 36:REDUCE(with prod 100)]
 [term 37:REDUCE(with prod 100)] [term 38:REDUCE(with prod 100)]
 [term 39:REDUCE(with prod 100)] [term 40:REDUCE(with prod 100)]
 [term 41:REDUCE(with prod 100)] [term 42:REDUCE(with prod 100)]
From state #117
 [term 5:REDUCE(with prod 97)] [term 6:REDUCE(with prod 97)]
 [term 7:REDUCE(with prod 97)] [term 8:REDUCE(with prod 97)]
 [term 9:REDUCE(with prod 97)] [term 10:REDUCE(with prod 97)]
 [term 11:REDUCE(with prod 97)] [term 12:REDUCE(with prod 97)]
 [term 13:REDUCE(with prod 97)] [term 14:REDUCE(with prod 97)]
 [term 15:REDUCE(with prod 97)] [term 16:REDUCE(with prod 97)]
 [term 17:REDUCE(with prod 97)] [term 18:REDUCE(with prod 97)]
 [term 19:REDUCE(with prod 97)] [term 20:REDUCE(with prod 97)]
 [term 21:REDUCE(with prod 97)] [term 22:REDUCE(with prod 97)]
 [term 23:REDUCE(with prod 97)] [term 24:REDUCE(with prod 97)]
 [term 25:REDUCE(with prod 97)] [term 26:REDUCE(with prod 97)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 97)] [term 31:REDUCE(with prod 97)]
 [term 32:REDUCE(with prod 97)] [term 33:REDUCE(with prod 97)]
 [term 34:REDUCE(with prod 97)] [term 36:REDUCE(with prod 97)]
 [term 37:REDUCE(with prod 97)] [term 38:SHIFT(to state 64)]
 [term 39:REDUCE(with prod 97)] [term 40:REDUCE(with prod 97)]
 [term 41:REDUCE(with prod 97)] [term 42:REDUCE(with prod 97)]
From state #118
 [term 33:REDUCE(with prod 15)] [term 39:REDUCE(with prod 15)]
From state #119
 [term 5:REDUCE(with prod 98)] [term 6:REDUCE(with prod 98)]
 [term 7:REDUCE(with prod 98)] [term 8:REDUCE(with prod 98)]
 [term 9:REDUCE(with prod 98)] [term 10:REDUCE(with prod 98)]
 [term 11:REDUCE(with prod 98)] [term 12:REDUCE(with prod 98)]
 [term 13:REDUCE(with prod 98)] [term 14:REDUCE(with prod 98)]
 [term 15:REDUCE(with prod 98)] [term 16:REDUCE(with prod 98)]
 [term 17:REDUCE(with prod 98)] [term 18:REDUCE(with prod 98)]
 [term 19:REDUCE(with prod 98)] [term 20:REDUCE(with prod 98)]
 [term 21:REDUCE(with prod 98)] [term 22:REDUCE(with prod 98)]
 [term 23:REDUCE(with prod 98)] [term 24:REDUCE(with prod 98)]
 [term 25:REDUCE(with prod 98)] [term 26:REDUCE(with prod 98)]
 [term 28:REDUCE(with prod 98)] [term 29:REDUCE(with prod 98)]
 [term 30:REDUCE(with prod 98)] [term 31:REDUCE(with prod 98)]
 [term 32:REDUCE(with prod 98)] [term 33:REDUCE(with prod 98)]
 [term 34:REDUCE(with prod 98)] [term 36:REDUCE(with prod 98)]
 [term 37:REDUCE(with prod 98)] [term 38:REDUCE(with prod 98)]
 [term 39:REDUCE(with prod 98)] [term 40:REDUCE(with prod 98)]
 [term 41:REDUCE(with prod 98)] [term 42:REDUCE(with prod 98)]
From state #120
 [term 33:REDUCE(with prod 12)] [term 39:REDUCE(with prod 12)]
From state #121
 [term 31:REDUCE(with prod 16)] [term 37:REDUCE(with prod 16)]
 [term 39:SHIFT(to state 126)]
From state #122
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #123
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 36:SHIFT(to state 124)] [term 38:SHIFT(to state 64)]
From state #124
 [term 33:REDUCE(with prod 14)] [term 39:REDUCE(with prod 14)]
From state #125
 [term 31:SHIFT(to state 133)] [term 37:SHIFT(to state 132)]
From state #126
 [term 34:SHIFT(to state 129)] [term 39:SHIFT(to state 128)]
From state #127
 [term 31:REDUCE(with prod 17)] [term 37:REDUCE(with prod 17)]
From state #128
 [term 31:REDUCE(with prod 19)] [term 37:REDUCE(with prod 19)]
From state #129
 [term 35:SHIFT(to state 130)]
From state #130
 [term 39:SHIFT(to state 131)]
From state #131
 [term 31:REDUCE(with prod 20)] [term 37:REDUCE(with prod 20)]
From state #132
 [term 39:SHIFT(to state 126)]
From state #133
 [term 32:SHIFT(to state 134)]
From state #134
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 33:REDUCE(with prod 21)] [term 34:SHIFT(to state 44)]
 [term 39:SHIFT(to state 141)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #135
 [term 5:REDUCE(with prod 27)] [term 6:REDUCE(with prod 27)]
 [term 7:REDUCE(with prod 27)] [term 8:REDUCE(with prod 27)]
 [term 9:REDUCE(with prod 27)] [term 10:REDUCE(with prod 27)]
 [term 11:REDUCE(with prod 27)] [term 14:REDUCE(with prod 27)]
 [term 18:REDUCE(with prod 27)] [term 28:REDUCE(with prod 27)]
 [term 29:REDUCE(with prod 27)] [term 30:REDUCE(with prod 27)]
 [term 32:REDUCE(with prod 27)] [term 33:REDUCE(with prod 27)]
 [term 34:REDUCE(with prod 27)] [term 39:REDUCE(with prod 27)]
 [term 40:REDUCE(with prod 27)] [term 41:REDUCE(with prod 27)]
 [term 42:REDUCE(with prod 27)]
From state #136
 [term 5:REDUCE(with prod 26)] [term 6:REDUCE(with prod 26)]
 [term 7:REDUCE(with prod 26)] [term 8:REDUCE(with prod 26)]
 [term 9:REDUCE(with prod 26)] [term 10:REDUCE(with prod 26)]
 [term 11:REDUCE(with prod 26)] [term 14:REDUCE(with prod 26)]
 [term 18:REDUCE(with prod 26)] [term 28:REDUCE(with prod 26)]
 [term 29:REDUCE(with prod 26)] [term 30:REDUCE(with prod 26)]
 [term 32:REDUCE(with prod 26)] [term 33:REDUCE(with prod 26)]
 [term 34:REDUCE(with prod 26)] [term 39:REDUCE(with prod 26)]
 [term 40:REDUCE(with prod 26)] [term 41:REDUCE(with prod 26)]
 [term 42:REDUCE(with prod 26)]
From state #137
 [term 5:REDUCE(with prod 31)] [term 6:REDUCE(with prod 31)]
 [term 7:REDUCE(with prod 31)] [term 8:REDUCE(with prod 31)]
 [term 9:REDUCE(with prod 31)] [term 10:REDUCE(with prod 31)]
 [term 11:REDUCE(with prod 31)] [term 14:REDUCE(with prod 31)]
 [term 18:REDUCE(with prod 31)] [term 28:REDUCE(with prod 31)]
 [term 29:REDUCE(with prod 31)] [term 30:REDUCE(with prod 31)]
 [term 32:REDUCE(with prod 31)] [term 33:REDUCE(with prod 31)]
 [term 34:REDUCE(with prod 31)] [term 39:REDUCE(with prod 31)]
 [term 40:REDUCE(with prod 31)] [term 41:REDUCE(with prod 31)]
 [term 42:REDUCE(with prod 31)]
From state #138
 [term 5:REDUCE(with prod 28)] [term 6:REDUCE(with prod 28)]
 [term 7:REDUCE(with prod 28)] [term 8:REDUCE(with prod 28)]
 [term 9:REDUCE(with prod 28)] [term 10:REDUCE(with prod 28)]
 [term 11:REDUCE(with prod 28)] [term 14:REDUCE(with prod 28)]
 [term 18:REDUCE(with prod 28)] [term 28:REDUCE(with prod 28)]
 [term 29:REDUCE(with prod 28)] [term 30:REDUCE(with prod 28)]
 [term 32:REDUCE(with prod 28)] [term 33:REDUCE(with prod 28)]
 [term 34:REDUCE(with prod 28)] [term 39:REDUCE(with prod 28)]
 [term 40:REDUCE(with prod 28)] [term 41:REDUCE(with prod 28)]
 [term 42:REDUCE(with prod 28)]
From state #139
 [term 30:SHIFT(to state 181)]
From state #140
 [term 30:SHIFT(to state 175)]
From state #141
 [term 12:REDUCE(with prod 102)] [term 13:REDUCE(with prod 102)]
 [term 14:REDUCE(with prod 102)] [term 15:REDUCE(with prod 102)]
 [term 16:REDUCE(with prod 102)] [term 17:REDUCE(with prod 102)]
 [term 19:REDUCE(with prod 102)] [term 20:REDUCE(with prod 102)]
 [term 21:REDUCE(with prod 102)] [term 22:REDUCE(with prod 102)]
 [term 23:REDUCE(with prod 102)] [term 24:REDUCE(with prod 102)]
 [term 25:REDUCE(with prod 102)] [term 26:REDUCE(with prod 102)]
 [term 27:REDUCE(with prod 102)] [term 28:REDUCE(with prod 102)]
 [term 29:REDUCE(with prod 102)] [term 30:SHIFT(to state 101)]
 [term 34:SHIFT(to state 166)] [term 36:REDUCE(with prod 102)]
 [term 38:REDUCE(with prod 102)] [term 39:SHIFT(to state 165)]
From state #142
 [term 5:REDUCE(with prod 25)] [term 6:REDUCE(with prod 25)]
 [term 7:REDUCE(with prod 25)] [term 8:REDUCE(with prod 25)]
 [term 9:REDUCE(with prod 25)] [term 10:REDUCE(with prod 25)]
 [term 11:REDUCE(with prod 25)] [term 14:REDUCE(with prod 25)]
 [term 18:REDUCE(with prod 25)] [term 28:REDUCE(with prod 25)]
 [term 29:REDUCE(with prod 25)] [term 30:REDUCE(with prod 25)]
 [term 32:REDUCE(with prod 25)] [term 33:REDUCE(with prod 25)]
 [term 34:REDUCE(with prod 25)] [term 39:REDUCE(with prod 25)]
 [term 40:REDUCE(with prod 25)] [term 41:REDUCE(with prod 25)]
 [term 42:REDUCE(with prod 25)]
From state #143
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 36:SHIFT(to state 164)]
 [term 39:SHIFT(to state 39)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #144
 [term 5:REDUCE(with prod 29)] [term 6:REDUCE(with prod 29)]
 [term 7:REDUCE(with prod 29)] [term 8:REDUCE(with prod 29)]
 [term 9:REDUCE(with prod 29)] [term 10:REDUCE(with prod 29)]
 [term 11:REDUCE(with prod 29)] [term 14:REDUCE(with prod 29)]
 [term 18:REDUCE(with prod 29)] [term 28:REDUCE(with prod 29)]
 [term 29:REDUCE(with prod 29)] [term 30:REDUCE(with prod 29)]
 [term 32:REDUCE(with prod 29)] [term 33:REDUCE(with prod 29)]
 [term 34:REDUCE(with prod 29)] [term 39:REDUCE(with prod 29)]
 [term 40:REDUCE(with prod 29)] [term 41:REDUCE(with prod 29)]
 [term 42:REDUCE(with prod 29)]
From state #145
 [term 36:SHIFT(to state 162)]
From state #146
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 33:SHIFT(to state 161)] [term 34:SHIFT(to state 44)]
 [term 39:SHIFT(to state 141)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #147
 [term 5:REDUCE(with prod 30)] [term 6:REDUCE(with prod 30)]
 [term 7:REDUCE(with prod 30)] [term 8:REDUCE(with prod 30)]
 [term 9:REDUCE(with prod 30)] [term 10:REDUCE(with prod 30)]
 [term 11:REDUCE(with prod 30)] [term 14:REDUCE(with prod 30)]
 [term 18:REDUCE(with prod 30)] [term 28:REDUCE(with prod 30)]
 [term 29:REDUCE(with prod 30)] [term 30:REDUCE(with prod 30)]
 [term 32:REDUCE(with prod 30)] [term 33:REDUCE(with prod 30)]
 [term 34:REDUCE(with prod 30)] [term 39:REDUCE(with prod 30)]
 [term 40:REDUCE(with prod 30)] [term 41:REDUCE(with prod 30)]
 [term 42:REDUCE(with prod 30)]
From state #148
 [term 5:REDUCE(with prod 24)] [term 6:REDUCE(with prod 24)]
 [term 7:REDUCE(with prod 24)] [term 8:REDUCE(with prod 24)]
 [term 9:REDUCE(with prod 24)] [term 10:REDUCE(with prod 24)]
 [term 11:REDUCE(with prod 24)] [term 14:REDUCE(with prod 24)]
 [term 18:REDUCE(with prod 24)] [term 28:REDUCE(with prod 24)]
 [term 29:REDUCE(with prod 24)] [term 30:REDUCE(with prod 24)]
 [term 32:REDUCE(with prod 24)] [term 33:REDUCE(with prod 24)]
 [term 34:REDUCE(with prod 24)] [term 39:REDUCE(with prod 24)]
 [term 40:REDUCE(with prod 24)] [term 41:REDUCE(with prod 24)]
 [term 42:REDUCE(with prod 24)]
From state #149
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 33:REDUCE(with prod 21)] [term 34:SHIFT(to state 44)]
 [term 39:SHIFT(to state 141)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #150
 [term 30:SHIFT(to state 154)]
From state #151
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 36:SHIFT(to state 153)] [term 38:SHIFT(to state 64)]
From state #152
 [term 5:REDUCE(with prod 22)] [term 7:REDUCE(with prod 22)]
 [term 8:REDUCE(with prod 22)] [term 9:REDUCE(with prod 22)]
 [term 10:REDUCE(with prod 22)] [term 11:REDUCE(with prod 22)]
 [term 14:REDUCE(with prod 22)] [term 18:REDUCE(with prod 22)]
 [term 28:REDUCE(with prod 22)] [term 29:REDUCE(with prod 22)]
 [term 30:REDUCE(with prod 22)] [term 32:REDUCE(with prod 22)]
 [term 33:REDUCE(with prod 22)] [term 34:REDUCE(with prod 22)]
 [term 39:REDUCE(with prod 22)] [term 40:REDUCE(with prod 22)]
 [term 41:REDUCE(with prod 22)] [term 42:REDUCE(with prod 22)]
From state #153
 [term 5:REDUCE(with prod 32)] [term 6:REDUCE(with prod 32)]
 [term 7:REDUCE(with prod 32)] [term 8:REDUCE(with prod 32)]
 [term 9:REDUCE(with prod 32)] [term 10:REDUCE(with prod 32)]
 [term 11:REDUCE(with prod 32)] [term 14:REDUCE(with prod 32)]
 [term 18:REDUCE(with prod 32)] [term 28:REDUCE(with prod 32)]
 [term 29:REDUCE(with prod 32)] [term 30:REDUCE(with prod 32)]
 [term 32:REDUCE(with prod 32)] [term 33:REDUCE(with prod 32)]
 [term 34:REDUCE(with prod 32)] [term 39:REDUCE(with prod 32)]
 [term 40:REDUCE(with prod 32)] [term 41:REDUCE(with prod 32)]
 [term 42:REDUCE(with prod 32)]
From state #154
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #155
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:SHIFT(to state 156)] [term 38:SHIFT(to state 64)]
From state #156
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #157
 [term 5:REDUCE(with prod 37)] [term 6:REDUCE(with prod 37)]
 [term 7:REDUCE(with prod 37)] [term 8:REDUCE(with prod 37)]
 [term 9:REDUCE(with prod 37)] [term 10:REDUCE(with prod 37)]
 [term 11:REDUCE(with prod 37)] [term 14:REDUCE(with prod 37)]
 [term 18:REDUCE(with prod 37)] [term 28:REDUCE(with prod 37)]
 [term 29:REDUCE(with prod 37)] [term 30:REDUCE(with prod 37)]
 [term 32:REDUCE(with prod 37)] [term 33:REDUCE(with prod 37)]
 [term 34:REDUCE(with prod 37)] [term 39:REDUCE(with prod 37)]
 [term 40:REDUCE(with prod 37)] [term 41:REDUCE(with prod 37)]
 [term 42:REDUCE(with prod 37)]
From state #158
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 33:SHIFT(to state 159)] [term 34:SHIFT(to state 44)]
 [term 39:SHIFT(to state 141)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #159
 [term 5:REDUCE(with prod 49)] [term 6:REDUCE(with prod 49)]
 [term 7:REDUCE(with prod 49)] [term 8:REDUCE(with prod 49)]
 [term 9:REDUCE(with prod 49)] [term 10:REDUCE(with prod 49)]
 [term 11:REDUCE(with prod 49)] [term 14:REDUCE(with prod 49)]
 [term 18:REDUCE(with prod 49)] [term 28:REDUCE(with prod 49)]
 [term 29:REDUCE(with prod 49)] [term 30:REDUCE(with prod 49)]
 [term 32:REDUCE(with prod 49)] [term 33:REDUCE(with prod 49)]
 [term 34:REDUCE(with prod 49)] [term 39:REDUCE(with prod 49)]
 [term 40:REDUCE(with prod 49)] [term 41:REDUCE(with prod 49)]
 [term 42:REDUCE(with prod 49)]
From state #160
 [term 5:REDUCE(with prod 23)] [term 7:REDUCE(with prod 23)]
 [term 8:REDUCE(with prod 23)] [term 9:REDUCE(with prod 23)]
 [term 10:REDUCE(with prod 23)] [term 11:REDUCE(with prod 23)]
 [term 14:REDUCE(with prod 23)] [term 18:REDUCE(with prod 23)]
 [term 28:REDUCE(with prod 23)] [term 29:REDUCE(with prod 23)]
 [term 30:REDUCE(with prod 23)] [term 32:REDUCE(with prod 23)]
 [term 33:REDUCE(with prod 23)] [term 34:REDUCE(with prod 23)]
 [term 39:REDUCE(with prod 23)] [term 40:REDUCE(with prod 23)]
 [term 41:REDUCE(with prod 23)] [term 42:REDUCE(with prod 23)]
From state #161
 [term 33:REDUCE(with prod 11)] [term 39:REDUCE(with prod 11)]
From state #162
 [term 5:REDUCE(with prod 46)] [term 6:REDUCE(with prod 46)]
 [term 7:REDUCE(with prod 46)] [term 8:REDUCE(with prod 46)]
 [term 9:REDUCE(with prod 46)] [term 10:REDUCE(with prod 46)]
 [term 11:REDUCE(with prod 46)] [term 14:REDUCE(with prod 46)]
 [term 18:REDUCE(with prod 46)] [term 28:REDUCE(with prod 46)]
 [term 29:REDUCE(with prod 46)] [term 30:REDUCE(with prod 46)]
 [term 32:REDUCE(with prod 46)] [term 33:REDUCE(with prod 46)]
 [term 34:REDUCE(with prod 46)] [term 39:REDUCE(with prod 46)]
 [term 40:REDUCE(with prod 46)] [term 41:REDUCE(with prod 46)]
 [term 42:REDUCE(with prod 46)]
From state #163
 [term 5:REDUCE(with prod 48)] [term 6:REDUCE(with prod 48)]
 [term 7:REDUCE(with prod 48)] [term 8:REDUCE(with prod 48)]
 [term 9:REDUCE(with prod 48)] [term 10:REDUCE(with prod 48)]
 [term 11:REDUCE(with prod 48)] [term 12:SHIFT(to state 61)]
 [term 13:SHIFT(to state 62)] [term 14:SHIFT(to state 57)]
 [term 15:SHIFT(to state 66)] [term 16:SHIFT(to state 58)]
 [term 17:SHIFT(to state 59)] [term 18:REDUCE(with prod 48)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 30:REDUCE(with prod 48)] [term 32:REDUCE(with prod 48)]
 [term 33:REDUCE(with prod 48)] [term 34:REDUCE(with prod 48)]
 [term 38:SHIFT(to state 64)] [term 39:REDUCE(with prod 48)]
 [term 40:REDUCE(with prod 48)] [term 41:REDUCE(with prod 48)]
 [term 42:REDUCE(with prod 48)]
From state #164
 [term 5:REDUCE(with prod 47)] [term 6:REDUCE(with prod 47)]
 [term 7:REDUCE(with prod 47)] [term 8:REDUCE(with prod 47)]
 [term 9:REDUCE(with prod 47)] [term 10:REDUCE(with prod 47)]
 [term 11:REDUCE(with prod 47)] [term 14:REDUCE(with prod 47)]
 [term 18:REDUCE(with prod 47)] [term 28:REDUCE(with prod 47)]
 [term 29:REDUCE(with prod 47)] [term 30:REDUCE(with prod 47)]
 [term 32:REDUCE(with prod 47)] [term 33:REDUCE(with prod 47)]
 [term 34:REDUCE(with prod 47)] [term 39:REDUCE(with prod 47)]
 [term 40:REDUCE(with prod 47)] [term 41:REDUCE(with prod 47)]
 [term 42:REDUCE(with prod 47)]
From state #165
 [term 27:SHIFT(to state 172)]
From state #166
 [term 35:SHIFT(to state 167)]
From state #167
 [term 39:SHIFT(to state 168)]
From state #168
 [term 27:SHIFT(to state 169)]
From state #169
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #170
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 36:SHIFT(to state 171)] [term 38:SHIFT(to state 64)]
From state #171
 [term 5:REDUCE(with prod 34)] [term 6:REDUCE(with prod 34)]
 [term 7:REDUCE(with prod 34)] [term 8:REDUCE(with prod 34)]
 [term 9:REDUCE(with prod 34)] [term 10:REDUCE(with prod 34)]
 [term 11:REDUCE(with prod 34)] [term 14:REDUCE(with prod 34)]
 [term 18:REDUCE(with prod 34)] [term 28:REDUCE(with prod 34)]
 [term 29:REDUCE(with prod 34)] [term 30:REDUCE(with prod 34)]
 [term 32:REDUCE(with prod 34)] [term 33:REDUCE(with prod 34)]
 [term 34:REDUCE(with prod 34)] [term 39:REDUCE(with prod 34)]
 [term 40:REDUCE(with prod 34)] [term 41:REDUCE(with prod 34)]
 [term 42:REDUCE(with prod 34)]
From state #172
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #173
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 36:SHIFT(to state 174)] [term 38:SHIFT(to state 64)]
From state #174
 [term 5:REDUCE(with prod 33)] [term 6:REDUCE(with prod 33)]
 [term 7:REDUCE(with prod 33)] [term 8:REDUCE(with prod 33)]
 [term 9:REDUCE(with prod 33)] [term 10:REDUCE(with prod 33)]
 [term 11:REDUCE(with prod 33)] [term 14:REDUCE(with prod 33)]
 [term 18:REDUCE(with prod 33)] [term 28:REDUCE(with prod 33)]
 [term 29:REDUCE(with prod 33)] [term 30:REDUCE(with prod 33)]
 [term 32:REDUCE(with prod 33)] [term 33:REDUCE(with prod 33)]
 [term 34:REDUCE(with prod 33)] [term 39:REDUCE(with prod 33)]
 [term 40:REDUCE(with prod 33)] [term 41:REDUCE(with prod 33)]
 [term 42:REDUCE(with prod 33)]
From state #175
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 39)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #176
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:SHIFT(to state 177)] [term 38:SHIFT(to state 64)]
From state #177
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #178
 [term 5:REDUCE(with prod 35)] [term 6:SHIFT(to state 179)]
 [term 7:REDUCE(with prod 35)] [term 8:REDUCE(with prod 35)]
 [term 9:REDUCE(with prod 35)] [term 10:REDUCE(with prod 35)]
 [term 11:REDUCE(with prod 35)] [term 14:REDUCE(with prod 35)]
 [term 18:REDUCE(with prod 35)] [term 28:REDUCE(with prod 35)]
 [term 29:REDUCE(with prod 35)] [term 30:REDUCE(with prod 35)]
 [term 32:REDUCE(with prod 35)] [term 33:REDUCE(with prod 35)]
 [term 34:REDUCE(with prod 35)] [term 39:REDUCE(with prod 35)]
 [term 40:REDUCE(with prod 35)] [term 41:REDUCE(with prod 35)]
 [term 42:REDUCE(with prod 35)]
From state #179
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #180
 [term 5:REDUCE(with prod 36)] [term 6:REDUCE(with prod 36)]
 [term 7:REDUCE(with prod 36)] [term 8:REDUCE(with prod 36)]
 [term 9:REDUCE(with prod 36)] [term 10:REDUCE(with prod 36)]
 [term 11:REDUCE(with prod 36)] [term 14:REDUCE(with prod 36)]
 [term 18:REDUCE(with prod 36)] [term 28:REDUCE(with prod 36)]
 [term 29:REDUCE(with prod 36)] [term 30:REDUCE(with prod 36)]
 [term 32:REDUCE(with prod 36)] [term 33:REDUCE(with prod 36)]
 [term 34:REDUCE(with prod 36)] [term 39:REDUCE(with prod 36)]
 [term 40:REDUCE(with prod 36)] [term 41:REDUCE(with prod 36)]
 [term 42:REDUCE(with prod 36)]
From state #181
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 36:SHIFT(to state 183)]
 [term 39:SHIFT(to state 39)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #182
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 36:SHIFT(to state 197)] [term 38:SHIFT(to state 64)]
From state #183
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 36:SHIFT(to state 185)]
 [term 39:SHIFT(to state 39)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #184
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 36:SHIFT(to state 191)] [term 38:SHIFT(to state 64)]
From state #185
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 31:SHIFT(to state 187)] [term 34:SHIFT(to state 44)]
 [term 39:SHIFT(to state 39)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #186
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:SHIFT(to state 189)] [term 38:SHIFT(to state 64)]
From state #187
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #188
 [term 5:REDUCE(with prod 38)] [term 6:REDUCE(with prod 38)]
 [term 7:REDUCE(with prod 38)] [term 8:REDUCE(with prod 38)]
 [term 9:REDUCE(with prod 38)] [term 10:REDUCE(with prod 38)]
 [term 11:REDUCE(with prod 38)] [term 14:REDUCE(with prod 38)]
 [term 18:REDUCE(with prod 38)] [term 28:REDUCE(with prod 38)]
 [term 29:REDUCE(with prod 38)] [term 30:REDUCE(with prod 38)]
 [term 32:REDUCE(with prod 38)] [term 33:REDUCE(with prod 38)]
 [term 34:REDUCE(with prod 38)] [term 39:REDUCE(with prod 38)]
 [term 40:REDUCE(with prod 38)] [term 41:REDUCE(with prod 38)]
 [term 42:REDUCE(with prod 38)]
From state #189
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #190
 [term 5:REDUCE(with prod 41)] [term 6:REDUCE(with prod 41)]
 [term 7:REDUCE(with prod 41)] [term 8:REDUCE(with prod 41)]
 [term 9:REDUCE(with prod 41)] [term 10:REDUCE(with prod 41)]
 [term 11:REDUCE(with prod 41)] [term 14:REDUCE(with prod 41)]
 [term 18:REDUCE(with prod 41)] [term 28:REDUCE(with prod 41)]
 [term 29:REDUCE(with prod 41)] [term 30:REDUCE(with prod 41)]
 [term 32:REDUCE(with prod 41)] [term 33:REDUCE(with prod 41)]
 [term 34:REDUCE(with prod 41)] [term 39:REDUCE(with prod 41)]
 [term 40:REDUCE(with prod 41)] [term 41:REDUCE(with prod 41)]
 [term 42:REDUCE(with prod 41)]
From state #191
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 31:SHIFT(to state 193)] [term 34:SHIFT(to state 44)]
 [term 39:SHIFT(to state 39)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #192
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:SHIFT(to state 195)] [term 38:SHIFT(to state 64)]
From state #193
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #194
 [term 5:REDUCE(with prod 40)] [term 6:REDUCE(with prod 40)]
 [term 7:REDUCE(with prod 40)] [term 8:REDUCE(with prod 40)]
 [term 9:REDUCE(with prod 40)] [term 10:REDUCE(with prod 40)]
 [term 11:REDUCE(with prod 40)] [term 14:REDUCE(with prod 40)]
 [term 18:REDUCE(with prod 40)] [term 28:REDUCE(with prod 40)]
 [term 29:REDUCE(with prod 40)] [term 30:REDUCE(with prod 40)]
 [term 32:REDUCE(with prod 40)] [term 33:REDUCE(with prod 40)]
 [term 34:REDUCE(with prod 40)] [term 39:REDUCE(with prod 40)]
 [term 40:REDUCE(with prod 40)] [term 41:REDUCE(with prod 40)]
 [term 42:REDUCE(with prod 40)]
From state #195
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #196
 [term 5:REDUCE(with prod 44)] [term 6:REDUCE(with prod 44)]
 [term 7:REDUCE(with prod 44)] [term 8:REDUCE(with prod 44)]
 [term 9:REDUCE(with prod 44)] [term 10:REDUCE(with prod 44)]
 [term 11:REDUCE(with prod 44)] [term 14:REDUCE(with prod 44)]
 [term 18:REDUCE(with prod 44)] [term 28:REDUCE(with prod 44)]
 [term 29:REDUCE(with prod 44)] [term 30:REDUCE(with prod 44)]
 [term 32:REDUCE(with prod 44)] [term 33:REDUCE(with prod 44)]
 [term 34:REDUCE(with prod 44)] [term 39:REDUCE(with prod 44)]
 [term 40:REDUCE(with prod 44)] [term 41:REDUCE(with prod 44)]
 [term 42:REDUCE(with prod 44)]
From state #197
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 34:SHIFT(to state 44)] [term 36:SHIFT(to state 199)]
 [term 39:SHIFT(to state 39)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #198
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 36:SHIFT(to state 205)] [term 38:SHIFT(to state 64)]
From state #199
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 31:SHIFT(to state 201)] [term 34:SHIFT(to state 44)]
 [term 39:SHIFT(to state 39)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #200
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:SHIFT(to state 203)] [term 38:SHIFT(to state 64)]
From state #201
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #202
 [term 5:REDUCE(with prod 39)] [term 6:REDUCE(with prod 39)]
 [term 7:REDUCE(with prod 39)] [term 8:REDUCE(with prod 39)]
 [term 9:REDUCE(with prod 39)] [term 10:REDUCE(with prod 39)]
 [term 11:REDUCE(with prod 39)] [term 14:REDUCE(with prod 39)]
 [term 18:REDUCE(with prod 39)] [term 28:REDUCE(with prod 39)]
 [term 29:REDUCE(with prod 39)] [term 30:REDUCE(with prod 39)]
 [term 32:REDUCE(with prod 39)] [term 33:REDUCE(with prod 39)]
 [term 34:REDUCE(with prod 39)] [term 39:REDUCE(with prod 39)]
 [term 40:REDUCE(with prod 39)] [term 41:REDUCE(with prod 39)]
 [term 42:REDUCE(with prod 39)]
From state #203
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #204
 [term 5:REDUCE(with prod 43)] [term 6:REDUCE(with prod 43)]
 [term 7:REDUCE(with prod 43)] [term 8:REDUCE(with prod 43)]
 [term 9:REDUCE(with prod 43)] [term 10:REDUCE(with prod 43)]
 [term 11:REDUCE(with prod 43)] [term 14:REDUCE(with prod 43)]
 [term 18:REDUCE(with prod 43)] [term 28:REDUCE(with prod 43)]
 [term 29:REDUCE(with prod 43)] [term 30:REDUCE(with prod 43)]
 [term 32:REDUCE(with prod 43)] [term 33:REDUCE(with prod 43)]
 [term 34:REDUCE(with prod 43)] [term 39:REDUCE(with prod 43)]
 [term 40:REDUCE(with prod 43)] [term 41:REDUCE(with prod 43)]
 [term 42:REDUCE(with prod 43)]
From state #205
 [term 10:SHIFT(to state 47)] [term 14:SHIFT(to state 45)]
 [term 18:SHIFT(to state 32)] [term 28:SHIFT(to state 28)]
 [term 29:SHIFT(to state 35)] [term 30:SHIFT(to state 38)]
 [term 31:SHIFT(to state 207)] [term 34:SHIFT(to state 44)]
 [term 39:SHIFT(to state 39)] [term 40:SHIFT(to state 41)]
 [term 41:SHIFT(to state 37)] [term 42:SHIFT(to state 27)]
From state #206
 [term 12:SHIFT(to state 61)] [term 13:SHIFT(to state 62)]
 [term 14:SHIFT(to state 57)] [term 15:SHIFT(to state 66)]
 [term 16:SHIFT(to state 58)] [term 17:SHIFT(to state 59)]
 [term 19:SHIFT(to state 56)] [term 20:SHIFT(to state 70)]
 [term 21:SHIFT(to state 63)] [term 22:SHIFT(to state 67)]
 [term 23:SHIFT(to state 69)] [term 24:SHIFT(to state 71)]
 [term 25:SHIFT(to state 65)] [term 26:SHIFT(to state 68)]
 [term 28:SHIFT(to state 55)] [term 29:SHIFT(to state 60)]
 [term 31:SHIFT(to state 209)] [term 38:SHIFT(to state 64)]
From state #207
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #208
 [term 5:REDUCE(with prod 42)] [term 6:REDUCE(with prod 42)]
 [term 7:REDUCE(with prod 42)] [term 8:REDUCE(with prod 42)]
 [term 9:REDUCE(with prod 42)] [term 10:REDUCE(with prod 42)]
 [term 11:REDUCE(with prod 42)] [term 14:REDUCE(with prod 42)]
 [term 18:REDUCE(with prod 42)] [term 28:REDUCE(with prod 42)]
 [term 29:REDUCE(with prod 42)] [term 30:REDUCE(with prod 42)]
 [term 32:REDUCE(with prod 42)] [term 33:REDUCE(with prod 42)]
 [term 34:REDUCE(with prod 42)] [term 39:REDUCE(with prod 42)]
 [term 40:REDUCE(with prod 42)] [term 41:REDUCE(with prod 42)]
 [term 42:REDUCE(with prod 42)]
From state #209
 [term 5:SHIFT(to state 140)] [term 7:SHIFT(to state 150)]
 [term 8:SHIFT(to state 139)] [term 9:SHIFT(to state 145)]
 [term 10:SHIFT(to state 47)] [term 11:SHIFT(to state 143)]
 [term 14:SHIFT(to state 45)] [term 18:SHIFT(to state 32)]
 [term 28:SHIFT(to state 28)] [term 29:SHIFT(to state 35)]
 [term 30:SHIFT(to state 38)] [term 32:SHIFT(to state 149)]
 [term 34:SHIFT(to state 44)] [term 39:SHIFT(to state 141)]
 [term 40:SHIFT(to state 41)] [term 41:SHIFT(to state 37)]
 [term 42:SHIFT(to state 27)]
From state #210
 [term 5:REDUCE(with prod 45)] [term 6:REDUCE(with prod 45)]
 [term 7:REDUCE(with prod 45)] [term 8:REDUCE(with prod 45)]
 [term 9:REDUCE(with prod 45)] [term 10:REDUCE(with prod 45)]
 [term 11:REDUCE(with prod 45)] [term 14:REDUCE(with prod 45)]
 [term 18:REDUCE(with prod 45)] [term 28:REDUCE(with prod 45)]
 [term 29:REDUCE(with prod 45)] [term 30:REDUCE(with prod 45)]
 [term 32:REDUCE(with prod 45)] [term 33:REDUCE(with prod 45)]
 [term 34:REDUCE(with prod 45)] [term 39:REDUCE(with prod 45)]
 [term 40:REDUCE(with prod 45)] [term 41:REDUCE(with prod 45)]
 [term 42:REDUCE(with prod 45)]
From state #211
 [term 31:REDUCE(with prod 18)] [term 37:REDUCE(with prod 18)]
From state #212
 [term 33:SHIFT(to state 213)] [term 39:SHIFT(to state 10)]
From state #213
 [term 0:REDUCE(with prod 4)] [term 3:REDUCE(with prod 4)]
From state #214
 [term 0:REDUCE(with prod 1)]
From state #215
 [term 0:REDUCE(with prod 3)] [term 3:REDUCE(with prod 3)]
------------------------------
-------- REDUCE_TABLE --------
From state #0
 [non term 1->state 2] [non term 2->state 1] [non term 3->state 3]
From state #1
 [non term 3->state 215]
From state #2
From state #3
From state #4
From state #5
From state #6
 [non term 4->state 212] [non term 5->state 14] [non term 6->state 13]
 [non term 7->state 12]
From state #7
From state #8
From state #9
 [non term 4->state 11] [non term 5->state 14] [non term 6->state 13]
 [non term 7->state 12]
From state #10
From state #11
 [non term 5->state 16] [non term 6->state 13] [non term 7->state 12]
From state #12
From state #13
From state #14
From state #15
From state #16
From state #17
From state #18
From state #19
From state #20
From state #21
From state #22
 [non term 8->state 29] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #23
From state #24
From state #25
From state #26
From state #27
From state #28
 [non term 8->state 119] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #29
From state #30
From state #31
From state #32
 [non term 8->state 117] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #33
From state #34
From state #35
 [non term 8->state 116] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #36
From state #37
From state #38
 [non term 8->state 104] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #39
From state #40
From state #41
From state #42
From state #43
From state #44
 [non term 8->state 95] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #45
 [non term 8->state 54] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #46
From state #47
From state #48
From state #49
From state #50
From state #51
From state #52
From state #53
From state #54
From state #55
From state #56
 [non term 8->state 94] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #57
 [non term 8->state 93] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #58
 [non term 8->state 92] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #59
 [non term 8->state 91] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #60
From state #61
From state #62
 [non term 8->state 87] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #63
 [non term 8->state 86] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #64
From state #65
 [non term 8->state 78] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #66
 [non term 8->state 77] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #67
 [non term 8->state 76] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #68
 [non term 8->state 75] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #69
 [non term 8->state 74] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #70
 [non term 8->state 73] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #71
 [non term 8->state 72] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #72
From state #73
From state #74
From state #75
From state #76
From state #77
From state #78
From state #79
From state #80
 [non term 8->state 81] [non term 9->state 82] [non term 22->state 50]
 [non term 23->state 30] [non term 26->state 36] [non term 27->state 43]
 [non term 29->state 25] [non term 30->state 46] [non term 31->state 49]
 [non term 32->state 23] [non term 33->state 40] [non term 34->state 26]
 [non term 35->state 34] [non term 36->state 24] [non term 37->state 31]
 [non term 38->state 42] [non term 39->state 33] [non term 40->state 48]
From state #81
From state #82
From state #83
 [non term 8->state 85] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #84
From state #85
From state #86
From state #87
From state #88
From state #89
From state #90
From state #91
From state #92
From state #93
From state #94
From state #95
From state #96
From state #97
From state #98
From state #99
 [non term 8->state 100] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #100
From state #101
 [non term 8->state 81] [non term 9->state 102] [non term 22->state 50]
 [non term 23->state 30] [non term 26->state 36] [non term 27->state 43]
 [non term 29->state 25] [non term 30->state 46] [non term 31->state 49]
 [non term 32->state 23] [non term 33->state 40] [non term 34->state 26]
 [non term 35->state 34] [non term 36->state 24] [non term 37->state 31]
 [non term 38->state 42] [non term 39->state 33] [non term 40->state 48]
From state #102
From state #103
From state #104
From state #105
From state #106
From state #107
From state #108
From state #109
From state #110
 [non term 8->state 111] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #111
From state #112
From state #113
 [non term 8->state 114] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #114
From state #115
From state #116
From state #117
From state #118
From state #119
From state #120
From state #121
 [non term 10->state 125] [non term 11->state 127]
From state #122
 [non term 8->state 123] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #123
From state #124
From state #125
From state #126
From state #127
From state #128
From state #129
From state #130
From state #131
From state #132
 [non term 11->state 211]
From state #133
From state #134
 [non term 8->state 151] [non term 12->state 146] [non term 13->state 152]
 [non term 14->state 148] [non term 15->state 142] [non term 16->state 136]
 [non term 17->state 135] [non term 18->state 138] [non term 19->state 144]
 [non term 20->state 147] [non term 21->state 137] [non term 22->state 50]
 [non term 23->state 30] [non term 26->state 36] [non term 27->state 43]
 [non term 29->state 25] [non term 30->state 46] [non term 31->state 49]
 [non term 32->state 23] [non term 33->state 40] [non term 34->state 26]
 [non term 35->state 34] [non term 36->state 24] [non term 37->state 31]
 [non term 38->state 42] [non term 39->state 33] [non term 40->state 48]
From state #135
From state #136
From state #137
From state #138
From state #139
From state #140
From state #141
From state #142
From state #143
 [non term 8->state 163] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #144
From state #145
From state #146
 [non term 8->state 151] [non term 13->state 160] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #147
From state #148
From state #149
 [non term 8->state 151] [non term 12->state 158] [non term 13->state 152]
 [non term 14->state 148] [non term 15->state 142] [non term 16->state 136]
 [non term 17->state 135] [non term 18->state 138] [non term 19->state 144]
 [non term 20->state 147] [non term 21->state 137] [non term 22->state 50]
 [non term 23->state 30] [non term 26->state 36] [non term 27->state 43]
 [non term 29->state 25] [non term 30->state 46] [non term 31->state 49]
 [non term 32->state 23] [non term 33->state 40] [non term 34->state 26]
 [non term 35->state 34] [non term 36->state 24] [non term 37->state 31]
 [non term 38->state 42] [non term 39->state 33] [non term 40->state 48]
From state #150
From state #151
From state #152
From state #153
From state #154
 [non term 8->state 155] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #155
From state #156
 [non term 8->state 151] [non term 13->state 157] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #157
From state #158
 [non term 8->state 151] [non term 13->state 160] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #159
From state #160
From state #161
From state #162
From state #163
From state #164
From state #165
From state #166
From state #167
From state #168
From state #169
 [non term 8->state 170] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #170
From state #171
From state #172
 [non term 8->state 173] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #173
From state #174
From state #175
 [non term 8->state 176] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #176
From state #177
 [non term 8->state 151] [non term 13->state 178] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #178
From state #179
 [non term 8->state 151] [non term 13->state 180] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #180
From state #181
 [non term 8->state 182] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #182
From state #183
 [non term 8->state 184] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #184
From state #185
 [non term 8->state 186] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #186
From state #187
 [non term 8->state 151] [non term 13->state 188] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #188
From state #189
 [non term 8->state 151] [non term 13->state 190] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #190
From state #191
 [non term 8->state 192] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #192
From state #193
 [non term 8->state 151] [non term 13->state 194] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #194
From state #195
 [non term 8->state 151] [non term 13->state 196] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #196
From state #197
 [non term 8->state 198] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #198
From state #199
 [non term 8->state 200] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #200
From state #201
 [non term 8->state 151] [non term 13->state 202] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #202
From state #203
 [non term 8->state 151] [non term 13->state 204] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #204
From state #205
 [non term 8->state 206] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #206
From state #207
 [non term 8->state 151] [non term 13->state 208] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #208
From state #209
 [non term 8->state 151] [non term 13->state 210] [non term 14->state 148]
 [non term 15->state 142] [non term 16->state 136] [non term 17->state 135]
 [non term 18->state 138] [non term 19->state 144] [non term 20->state 147]
 [non term 21->state 137] [non term 22->state 50] [non term 23->state 30]
 [non term 26->state 36] [non term 27->state 43] [non term 29->state 25]
 [non term 30->state 46] [non term 31->state 49] [non term 32->state 23]
 [non term 33->state 40] [non term 34->state 26] [non term 35->state 34]
 [non term 36->state 24] [non term 37->state 31] [non term 38->state 42]
 [non term 39->state 33] [non term 40->state 48]
From state #210
From state #211
From state #212
 [non term 5->state 16] [non term 6->state 13] [non term 7->state 12]
From state #213
From state #214
From state #215
-----------------------------
Closing files...
------- CUP v0.10k Parser Generation Summary -------
  0 errors and 37 warnings
  43 terminals, 41 non-terminals, and 106 productions declared, 
  producing 216 unique parse states.
  1 terminal declared but not used.
  0 non-terminal declared but not used.
  0 productions never reduced.
  32 conflicts detected (100 expected).
  Code written to "Parser.java", and "TokenIds.java".
---------------------------------------------------- (v0.10k)
